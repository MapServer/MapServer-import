MS RFC 52: One-pass query processing
======================================================================

:Date: 2009/03/08
:Authors: Steve Lime
:Contact: sdlime at comcast.net
:Last Edited: 2009/03/08
:Status: Draft
:Version: MapServer 6.0
:Id:

Overview
------------------------------------------------------------------------------
This RFC proposes change(s) to the current of query (by point, by box, by shape, 
etc...) processing in MapServer.

Presently MapServer supports a very flexible query mechanism that utilizes two
passes through the data. This works by caching a list of feature IDs (pass one)
and then a second pass through the features for presentation (template, drawing,
or retrieval via MapScript. The obvious problem is the performance hit incurred
from the second pass (which can be quite steep with certain drivers).

Technical Solution
------------------------------------------------------------------------------
There are two (obvious) possible solutions to the problem. The first, a brute
force approach, would cache features (and their attributes) for presentation
later. The primary benefit is that the current query and presentation functions
could be retained. However, even moderately sized result sets could consume
loads of system memory and this approach is impractical for very large data
sets. One *could* apply limits on the number features allowed in the cache
and fall back to the two-pass approach if necessary. However, this doesn't 
help the worst case scenarios where the two-pass performance penalty is the
greatest.

Another more performant approach would be to integrate the processing done by 
the query functions into the mainstream feature retrieval system already in place 
for drawing and querying (e.g. msLayerWhichShapes() and msLayerNextShape()). The
current query functions basically just operate before or after those functions
anyway. For example, msQueryByAttributes() alters a layer's FILTER before
calling msLayerWhichShapes(). All of the query functions so some post processing
of features once retrieved. For example:

  - make sure there is a template present (at class or layer level)
  - doing basic intersection tests 

If those steps could be done optionally in msLayerWhichShapes() and msLayerNextShape()
then those functions could be used in lieu of the other query functions.

For this to work we would have to encapsulate queries in a new object that
could be passed to those functions to trigger pre- or post-processing as 
necessary. For example, we might consider defining a new queryObj that would
look like:

::

  typedef struct {
    int type; /* one of a number of enumerated query types */

    rectObj extent;
  
    char **layers; /* these mimic the qxxxxxx CGI arguments used for querying */
    char *string;
    char *item;
 
    char *slayer;
    featureListNodeObjPtr shape, currentshape; /* for querying by shape or other layer */
  } queryObj;

Query presentation code would simply open a layer, pass a query object to 
msLayerWhichShapes() and then do msLayerNextShape() repeatedly. 

Backwards Compatability Issues
------------------------------------------------------------------------------
The current two-pass system actually does present certain advantages and may be 
difficult to overcome with the second techincal solution.

1. We know if a query was successful or not *before* presentation takes place
and can throw an error (e.g. using the EMPTY in the webObj) easily. While we
still will know if a query returned no results, but we may be well into 
presentation by that time and will need new ways to deal with this. The EMPTY
parameter would probably become obsolete. Essentionally no results would not
be an error condition- perhaps a good thing.

2. Since the number of results found in each layer after the first pass is known
we populate a number of counter variables (e.g. total number of results) that
are accessible via template tags. While the counters would still work as normal
the totals would not be available. There are workarounds in some cases but not
in others.

3. One of the most useful MapServer query modes is QUERY which finds the closest
feature across one or more layers. It's the "more" that is problematic. The 
functions msLayerWhichShapes() and msLayerNextShapes() operate on a single layer 
while this particular query operates across layers. This type of query would have 
to be handled as a special case through a msFindClosestFeature() function.

4. The FEATUREQUERY modes in MapServer will provide a challenge. These are essentially
two queries done one after the other. Features from one layer are used to select
features from another (e.g. find all lakes within a county). This cannot be done 
using a single msLayerWhichShapes() and msLayerNextShapes() iteration so we'd need 
a function to move features from the initial query into a second queryObj for the 
second. Special consideration would be necessary in template processing to optionally
output the selection features.

5. MapScript access to query functions. Presently, the various MapScript query
methods are simply wrappers for the corresponding C function. Since the C functions
essentionally go away this interface will undoubtedly need to change. We can 
preserve the methods (they would just set queryObj members, perhaps more), but the 
access to results would change. A typical usage would be:

::

  # do the query
  $layer->queryByShape(...); # should open the layer(s) and call msLayerWhichShapes()
  while($shape = $layer->nextShape()) {
    # do something with it
  }
  $layer->close();

I would propose adding a new method to handle the "closest" case that would just
return a shapeObj (no more MS_SINGLE or MS_MULTIPLE).

Files Impacted
------------------------------------------------------------------------------

* mapserver.h: new queryObj, new enumeration, various fuctions coming and going

* maplayer.c: additions to msLayerWhichShapes(), msLayerNextShapes()

* maptemplate.c: refatoring of code to process tempates (2 places)

* mapgml.c: refactoring of code to output GML 2 & 3

* mapquery.c: pretty much a complete gutting

* mapdraw.c: refactoring of code that deals with drawing a querymap
