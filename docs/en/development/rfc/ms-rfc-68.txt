.. _rfc68:

=========================================================================
MS RFC 68: Support for combining features from multiple layers
=========================================================================

:Date:  2011/02/10
:Author: Tamas Szekeres
:Contact: szekerest at gmail.com
:Last Edited: $Date$
:Status: Discussion Draft
:Version: MapServer 6.0
:Id: $Id$

Description: This RFC proposes an implementation for creating a new data
providers (CONNECTIONTYPE=COMBINE and CONNECTIONTYPE=CLUSTER) which provide an option 
to combine features from multiple layers into a single layer and to cluster multiple 
features from a layer to single (aggregated) features based on their relative positions.

1. Overview
-----------

In order to make the maps perspicuous at a given view, we may require to limit
the number of the features rendered at neighbouring locations which would normally
overlap each other. Currently there's no such mechanism in MapServer which would
prevent from the symbols to overlap based on their relative locations. In a feasible
solution we should provide rendering the isolated symbols as is, but create new 
(clustered) features for those symbols that would overlap in a particular scale.
We would like to support clustering features from multiple layers as well. For this
reason we implement a separate layer data source (CONNECTIONTYPE=COMBINE) to represent 
features from multiple layers in a single layer then use this single layer as the 
data source of another layer (CONNECTIONTYPE=CLUSTER) which is responsible to perform
the clustering process and provide the clustered features at the output.
The following example will show how the layers are chained together to provide the final result:

::

  LAYER
    CONNECTIONTYPE CLUSTER
    NAME cluster
    PROCESSING "SOURCELAYER=combine"
    ...
  END
  LAYER
    CONNECTIONTYPE COMBINE
    NAME combine
    PROCESSING "SOURCELAYER=layer1,layer2"
    ...
  END
  LAYER
    CONNECTIONTYPE OGR
    NAME layer1
    ...
  END
  LAYER
    CONNECTIONTYPE SHAPE
    NAME layer2
    ...
  END
  
The order of the layers doesn't affect the result of the data processing, but it is suggested to set the
visibility of the source layers or the combine layers to false in order to avoid the duplication features on the map.

2. Combining features from multiple layers
------------------------------------------

This functionality will be implemented as a separate layer data source (CONNECTIONTYPE=COMBINE) which will
operate in the following way:

1) In LayerOpen it will open all of the source layers specified in the SOURCELAYER processing option
2) The LayerWhichShapes call is simply delegated to the underlying layers
3) LayerNextShape will iterate through the layers and call LayerNextShape for the subsequent shapes
   The layer index is assigned to the tileindex of the returned shapes. If we finish retrieving the
   shapes from one layer we start retrieving the features from the next source layer.
4) LayerGetShape will retrieve the layer based on the tile index and call LayerGetShape of this layer

The union layer and the source layers must have the same geometry type otherwise an error is generated in
the LayerOpen call.

2.1 Handling the layer attributes (items)
-----------------------------------------

In general the source layers must provide those attributes which are required when rendering the union layer, however 
the underlying data may contain further attributes, which are not used when fetching the data from the original source.
When all attributes are requested (in the query operations) then the union layer will provide only some aggegated
attributes (like the layer name or the group name of the source layer the feature belongs to). 
The set of the items can manually be overridden (and further attributes can be exposed) by using the following
processing option:

::

  PROCESSING "ITEMS=itemname1,itemname2,itemname3"

At this stage of the development, the driver will expose the following additional attributes:

1) Combine:SourceLayerName - The name of the source layer the feature belongs to
2) Combine:SourceLayerGroup - The group of the source layer the feature belongs to

2.2 Projections
---------------

It is suggested to use the same projection of the aggregate layer and the source layers. The layer provider
will anyway support transforming the feature positions between the source layers and the union layer.

2.3 Handling classes and styles
-------------------------------

We can define the symbology and labelling of the combine layers in the same way as any other layer by specifying 
the classes and styles. In addition we will also support the STYLEITEM AUTO option for the combine layer, which
is essential if we want to display the features in the same way as with the source layers. The source layers 
may also use the STYLEITEM AUTO setting if the underlying data soure provides that.

2.4 Query processing
--------------------

The queries on the combined layer will behave the same like for the other layers. All of the source 
layers are kept open until the combine layer is open. This will provide the single pass query to
work in case if the source layer supports it.

3. Clustering the features
--------------------------

This functionality will be implemented as a new layer data source (CONNECTIONTYPE=CLUSTER) which will
operate in the following way:

In LayerOpen it will open the source layer specified in the SOURCELAYER processing option.
In the LayerWhichShapes call we start a preprocessing phase. The features of the current extent
are retrieved from the source layer and passed through a clustering process with the following steps: 

1) For each feature we create a tentative cluster and create the aggregate attributes 
   (like the feature count and the average position)
2) We will retrieve all the neighbouring shapes (that has already been retrieved earlier) by using a quadtree
   (implemented in maptree.c) and then update a feature counts and the average positions at each intersecting cluster.
3) In a second turn we evaluate the tentative clusters based on their feature count and the offset of the 
   average position related to the initial position.
4) From the best ranking clusters we create new features and add them to the feature list in layerinfo
   
The preprocessed features are served from the collection layerinfo which is preserved until the layer is open.
The cluster layer will use futher processing options to control the clustering operation, like:

::

  PROCESSING "CLUSTERMAXDISTANCE=20"  # the maximum distance allowed between the features without forming a cluster
  PROCESSING "CLUSTERMAXCOUNT=100"    # the maximum number of the features in a cluster

3.1 Handling the feature attributes (items)
-------------------------------------------

The items handling approach of the cluster layer will be the same as described for the combine layer
At this stage of the development the driver will expose the following additional attributes:

1) Cluster:FeatureCount - The number of the features belonging to this cluster

When the source layer is a combine layer, then the related additional attributes 
(Combine:SourceLayerName and Combine:SourceLayerGroup) will also be available

3.2 Projections
---------------

It is suggested to use the same projection of the cluster layer and the source layers. The cluster layer data provider
will anyway support transforming the feature positions between the layers. The clustering process itself is
happening in the projection of the cluster layer. 

3.3 Handling classes and styles
-------------------------------

Since all of the features (including the clusters and the individual features) are served from the same layer
it is important to support the STYLEITEM AUTO option for the cluster layer as well. This will ensure that the
individual features will get the same look as it was displayed at the source layer. The STYLEITEM AUTO 
implementation will also provide the assignment the clustered features to the local class definitions.

3.4 Query processing
--------------------

The queries on the cluster layer will behave the same like for the other layers. The cluster database is
preserved until the cluster layer is open. We may however provide an additional option to retrieve the
individual shapes behind the clusters instead of the clustered shapes.

4. Implementation Details
-------------------------

In order to implement this enhancement the following changes should be made in the MapServer codebase:
   
1) Expose the functions treeNodeCreate and treeAddShapeId from maptree.c to allow using the quadtree
   implementation during the clustering process.
2) Modify the lexer to interpret the connection types (COMBINE and CLUSTER).
3) Implement mapcombine.c containing the code of the combine layer data source.
4) Implement mapcluster.c containing the code of the cluster layer data source.

4.1 Files affected
------------------

The following files will be modified/created by this RFC:

::

  maptree.c
  maptree.h
  maplexer.l
  mapserver.h
  Makefile.vc
  Makefile.in
  mapcombine.c (new)
  mapcluster.c (new)

4.2 MapScript Issues
--------------------

There's no need to modify the MapScript interface within the scope of this RFC.

4.3 Backwards Compatibilty Issues
---------------------------------

This change provides a new functionality with no backwards compatibility issues being considered.

5. Bug ID
---------

The ticket for RFC-68 (containing implementation code) can be found here.

Bug 3674_
 
.. _3674: http://trac.osgeo.org/mapserver/ticket/3674 

6. Voting history
-----------------

None


