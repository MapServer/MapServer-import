<h2>Splitting your data</h2>If you find yourself making several layers, all of them using the same dataset but filtering to only usse some of the records, you could probably do it better. If the criteria are static, one approach is to pre-split the data.<br /><br />The <i>ogr2ogr</i> utility can select on certain features from a datasource, and save them to a new data source. Thus, you can split your dataset into several smaller ones that are already effectively filtered, and remove the FILTER statement.<br /><br /><br /><h2>Shapefiles</h2>Use <i>shptree</i> to generate a spatial index on your shapefile. This is quick and easy ("shptree foo.shp") and generates a .qix file. Mapserver will automagically detect an index and use it.<br /><br />Note: Tileindex shapefiles can be indexed with shptree.<br /><br />Mapserver also comes with the <i>sortshp</i> utility. This reorganizes a shapefile, sorting it according to the values in one of its columns. If you're commonly filtering by criteria and it's almost always by a specific column, this can make the process slightly more efficient.<br /><br />Although shapefiles are a very fast data format, PostGIS is pretty speedy as well, especially if you use indexes well and have memory to throw at caching.<br /><br /><br /><h2>PostGIS</h2><p>The single biggest boost to performance is indexing. Make sure that there's a GIST index on the geometry column, and each record should also have an indexed primary key. If you used shp2pgsql, then these statements should create the necessary indexes:<br /></p><pre>ALTER TABLE table ADD PRIMARY KEY (gid);</pre><pre>CREATE INDEX table_the_geom ON table (the_geom) USING GIST;</pre><br />PostgreSQL also supports reorganizing the data in a table, such that it's physically sorted by the index. This allows PostgreSQL to be much more efficient in reading the indexed data. Use the CLUSTER command, e.g.<br /><br /><pre>CLUSTER the_geom ON table;</pre><br />Then there are numerous optimizations one can perform on the database server itself, aside from the geospatial component. The easiest is to increase <i>max_buffers</i> in the <i>postgresql.conf</i> file, which allows PostgreSQL to use more memory for caching. More information can be found at the &lt;a href="http://www.postgresql.org/"&gt;PostgreSQL website&lt;/a&gt;<br /><br /><br /><h2>Databases in General (PostGIS, Oracle, MySQL)</h2>By default, Mapserver opens and closes a new database connection for each database-driven layer in the mapfile. If you have several layers reading from the same database, this doesn't make a lot of sense. And with some databases (Oracle) establishing connections takes enough time that it can become significant.<br /><br /><br />Try adding this line to your database layers:<br /><pre>PROCESSING "CLOSE_CONNECTION=DEFER"</pre><br />This causes Mapserver to not close the database connection for each layer until after it has finished processing the mapfile (Why is this not the default? Who knows?) and this may shave a few seconds off of map generation times.<br /><br />