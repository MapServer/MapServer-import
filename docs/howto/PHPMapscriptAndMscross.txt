<hr class="docutils" />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Rodrigo Martín LÓPEZ GREGORIO</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">rodrigomlg (at) gmail (dot) com</td>
</tr>
<tr class="field"><th class="field-name">Last Updated:</th><td class="field-body">2007/06/14</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id1" name="id1">Introduction</a></li>
<li><a class="reference" href="#first-considerations" id="id2" name="id2">First considerations...</a></li>
<li><a class="reference" href="#starting" id="id3" name="id3">Starting...</a></li>
<li><a class="reference" href="#going-further" id="id4" name="id4">Going further...</a></li>
<li><a class="reference" href="#making-it-work-with-mscross" id="id5" name="id5">Making it work with msCross...</a></li>
</ul>
</div>
<br>
<div class="section" id="introduction">
<h3><a class="toc-backref" href="#table-of-contents" name="introduction">Introduction</a></h3>
<p>msCross is a great Javascript interface that provide a web interface to mapserver with basic functions like Zoom or Pan (and other advanced like wms support). The problem that many mapserver users confront first time they try to use this interface is that they normally started with PHP Mapscript and then they dont know how to connect their PHP-Mapscript files to msCross interface. Aditionally, PHP Mapscript allows mapserver users to create layers or add features dinamically wich could not be achieved with the use of just msCross. So I think that using msCross as client interface and letting PHP Mapscript do it job at server side most users can get great results.<br>You can get the last version of this library and see all the features it provides in the <a class="reference" href="http://datacrossing.crs4.it/en_Documentation_mscross.html">official page</a>. I have nothing to do with the Datacrossing people (wich I think have made a great work); I'm just a mscross very satisfied user.<br>
I wrote this text as response to a question in the mapserver users mailing list and bearing in mind that english is not my mother tongue it can be writed not as well as I want. However I was encouraged by a list member to publish it so here it is.</p>
</div>
<br>
<div class="section" id="first-considerations">
<h3><a class="toc-backref" href="#table-of-contents" name="first-considerations">First considerations...</a></h3>
<p>
First of all, if you play around a little bit with the mscross code, you will see that the way mscross obtains the image of the map is asking directly to mapserver cgi interface, generating the necesary url and assigning it to an &lt;img&gt; HTML element (created dinamically by the javascript code). So, what ajax interface was expecting from the server is an image file and not an HTML file. That is why you must modify your PHP Mapscript file to return an image file instead of just HTML code.
</p>
</div>
<br>
<div class="section" id="starting">
<h3><a class="toc-backref" href="#table-of-contents" name="starting">Starting...</a></h3>
<p>
So, lets go with a simple example... To make it simple, supose you have a mapfile ready to use with mapserver and do not need to create anything dinamically so the PHP Mapscript becomes quite simple. Lets supose the mapfile have a png OUTPUTFORMAT, and three LAYERS named "countrys" "rivers" and "sea". If the mapfile is located in /mymaps/ and it name is " example1.map", then the CGI url to obtain a map (the one generated by mscross) is something like this:
</p>
<p>
http://myserver/cgi-bin/mapserv.exe?<b>map</b>=/mymaps/example1.map&amp;<b>mode</b>=map (continues below) <br>&amp;<b>mapext</b>=5649512+6099485+5711778+6144474&amp;<b>mapsize</b>=800+600&amp;<b>layers</b>=countrys%20rivers%20sea
</p>
<p>
(note that I'm using mapserver for windows but on linux the url will be almost the same)
<p>
The "object" returned by mapserver CGI interface will be an Image object ( i.e. the content of the image).
</p>
<p>
So the first thing you need to use your PHPMapscript with the mscross interface is make that your PHP Mapscript file return an image object and not a html object with an &lt;img&gt; element on it. So, lets see the contest of this simple PHP Mapscript file:
</p>
<pre class="literal-block">
&lt;?php
header(&quot;Content-type: image/png&quot;);
//Before we send any data to the browser we set the header &quot;Content-type&quot;
//of the response to &quot;image/png&quot; so the browser interprets the content 
//of the response as a png image file.

$map = ms_newMapObj(&quot;/mymaps/example1.map&quot;);
// We create the map object based on the example1.map file as template

$map-&gt;setSize(800,600);
// and set the image size (resolution)
// Update: The map size must be setted before the extent, otherwise the extent 
// will be adjusted to the aspect ratio of the map defined on SIZE parameter
// of MAP object in your mapfile

$map-&gt;setExtent(5649512,6099485,5711778,6144474);
// We set the extent of map

$map-&gt;getLayerByName(&quot;countrys&quot;)-&gt;set(status,MS_ON);
$map-&gt;getLayerByName(&quot;rivers&quot;)-&gt;set(status,MS_ON);
$map-&gt;getLayerByName(&quot;sea&quot;)-&gt;set(status,MS_ON);
// Set the status of three layers to on

$image=$map-&gt;draw();
$imagename=$image-&gt;saveWebImage();
//Draw the image to a temp file and copy image name to the $imagename variable

$image = ImageCreateFromPng(&quot;/ms4w/tmp/&quot;.$imagename);
// Read the image saved previously to the $image variable

imagePng($image);
// Return the image content to the browser
?&gt;
</pre>
<p>
Maybe there is a way to avoid the save to disk and read from disk operation but I didn't waste too much time looking for an alternative. So the previous PHP Mapscript will create a mapobject, set the properties properly and then return the image to the browser just like an image object.
</p>
<p>
If you call this php file from your browser, the browser will get a png image file with the map drawed. Obviously the PHP Mapscript could be more complex, create layers, class and labels dinamically, but it must be always return an image file which is achieved with the header function in conjunct with the imagePng call at the end of the Mapscript.
</p>
</div>
<br>
<div class="section" id="going-further">
<h3><a class="toc-backref" href="#table-of-contents" name="going-further">Going further...</a></h3>
<p>
The next thing to do is make this Mapscript more flexible, so it could recieve the map extent, map size and layers (and maybe the mapfile even) as parameters. Sinse mscross use the GET method to obtain images we can modify our Mapscript file to get this parameters and set it properly. So, if we mantain the variables name as the ones used to get images from CGI interface to make it more simple we can modify our PHP Mapscript file so it can be more flexible and modify its output according to the url parameters:
</p>
<pre class="literal-block">
&lt;?php
header(&quot;Content-type: image/png&quot;);

$map = ms_newMapObj($_GET['map']);
// We create the map object based on the mapfile received as parameter

$size = explode(&quot; &quot;,$_GET['mapsize']);
$map-&gt;setSize($size[0], $size[1]);
// and set the image size (resolution) based on mapsize parameter
// Update: The map size must be setted before the extent, otherwise the extent 
// will be adjusted to the aspect ratio of the map defined on SIZE parameter
// of MAP object in your mapfile

$extent = explode(&quot; &quot;,$_GET['mapext']);
$map-&gt;setExtent($extent[0], $extent[1], $extent[2], $extent[3]);
// We get the mapext parameter... split it on its 4 parts using 
// the space character as splitter

$layerslist=$_GET['layers'];
for ($layer = 0; $layer &lt; $map-&gt;numlayers; $layer++) {
    $lay = $map-&gt;getLayer($layer);
    if ((strpos($layerslist,($map-&gt;getLayer($layer)-&gt;name)) !== false) 
        or (($map-&gt;getLayer($layer)-&gt;group != &quot;&quot;) and 
        (strpos($layerslist,($map-&gt;getLayer($layer)-&gt;group)) !== false))){
// if the name property of actual $lay object is in $layerslist
// or the group property is in $layerslist then the layer was requested
//so we set the status ON... otherwise we set the stat to OFF
        $lay-&gt;set(status,MS_ON);
    } else {
        $lay-&gt;set(status,MS_OFF);
    }
}

// The next lines are the same as previous mapscript
$image=$map-&gt;draw();
$imagename=$image-&gt;saveWebImage();
$image = ImageCreateFromPng(&quot;/ms4w/tmp/&quot;.$imagename);
imagePng($image);
?&gt;
</pre>
<p>
If you want to get a map drawed throw this mapscript, you must now pass various parameters in the url... something like this:
</p>
<p>
http://myserver/myPHPMapscript.php?<b>map</b>=/mymaps/example1.map (continues below) <br>&amp;<b>mapext</b>=5649512+6099485+5711778+6144474&amp;<b>mapsize</b>=800+600 (continues below) <br>&amp;<b>layers</b>=countrys%20rivers%20sea
</p>
<p>
Again, the Mapscript could be more complex but always must return an image object.
</p>
</div>
<br>
<div class="section" id="making-it-work-with-mscrossr">
<h3><a class="toc-backref" href="#table-of-contents" name="making-it-work-with-mscrossr">Making it work with msCross...</a></h3>
<p>
So the last thing we must do is get it work with the mscross ajax... Lets work with the last version of mscross javascript available <a href="http://datacrossing.crs4.it/download.php?l=en&id=mscross-1.1.8.js">here</a></p>
<p>
First take a look at the get_map_url() method of mscross class on mscross-1.1.8.js file... It looks something like this (I remove some lines which gives support to use wms servers):
</p>
<pre class="literal-block">
this.get_map_url = function()
{
  var my_url;

  if (_protocol == 'mapservercgi')
  {
    var size = 'mapsize=' + (_map_w+_map_w_bord+_map_w_bord) + '+'
                          + (_map_h+_map_h_bord+_map_h_bord);
    var ext  = 'mapext=' + (_ext_Xmin-i.wPixel2real(_map_w_bord)) + '+'
                         + (_ext_Ymin-i.hPixel2real(_map_h_bord)) + '+'
                         + (_ext_Xmax+i.wPixel2real(_map_w_bord)) + '+'
                         + (_ext_Ymax+i.hPixel2real(_map_h_bord)) ;

    <b>my_url = _cgi + '?mode=' + _mode + '&' + _map_file + '&' +
             ext + '&' + size + '&layers=' + _layers;</b>

    // Opera9 Bug Fix (onload event don't work if image is in cache)
    if (browser.isOP ) {my_url = my_url + '&' + Math.random();}
  }

  return my_url + '&' + _args;
}
</pre>
<p>
Basically, this function build the url of the Mapserver CGI interface, so we must get it work with our recently created PHP Mapscript file. If you take a look at the line in <b>bold</b>, there is where the url is created:
</p>
<p>
<b>my_url = _cgi + '?mode=' + _mode + '&' + _map_file + '&' + ext + '&' + size + '&layers=' + _layers;</b>
</p>
<p>
there are some fixed (strings) parts and some variable parts in this line... first it put the _cgi content which is set using the mscross setCgi() method. Then it add the mode parameter that we dont need to use so it could be removed. Then the mapfile parameter which is set using the mscross setMapFile() method. After mapfile parameter it puts the extent parameter at ext variable which is created some lines before and is based on the mscross object properties setted by the setFullExtent() and setExtent() methods and the size parameter (width and height of image) which are calculated on the mscross object creation from container div width and height. Finaly it pass the layers parameter based on _layers variable setted by the mscross setLayers() method.
</p>
<p>
So we want to get this url look like the one we create for the second PHP Mapscript file, so we need to set the variables properly to get my_url look like:
</p>
<p>
http://myserver/myPHPMapscript.php?<b>map</b>=/mymaps/example1.map (continues below) <br>&amp;<b>mapext</b>=5649512+6099485+5711778+6144474&amp;<b>mapsize</b>=800+600 (continues below) <br>&amp;<b>layers</b>=countrys%20rivers%20sea
</p>
<p>
The way to obtain this is:
</p>
<p>
set the _cgi variable to "http://myserver/myPHPMapscript.php" using the setCgi() method.<br>
set the mapfile to "/mymaps/example1.map" using the setMapFile() method.<br>
set map extention to (5649512,6099485,5711778,6144474) using the setFullExtent() method.<br>
and set the layers to "countrys rivers sea" using the setLayers() method<br>
(the map size is setted automatically when the mscross object is created).<br>
and finally if yo want to avoid the pass of mode parameter you can modify the get_map_url() method and remove it from the line as follows:
</p>
<p>
<b>my_url = _cgi + '?' + _map_file + '&amp;' + ext + '&amp;' + size + '&amp;layers=' + _layers;</b>
</p>
<p>
So, at this point we can make a simple html file to get our mscross and PHP Mapscript working together... a simple html could be the next one:
</p>
<pre class="literal-block">
&lt;html&gt;
&lt;script src=&quot;mscross-1.1.8.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;body&gt;
&lt;div id=&quot;map_tag&quot; style=&quot;position:absolute; 
    top:10px; left:10px; width: 800px; height: 600px; border-width:1px;
    border-color:#000088; border-style:solid;&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
myMap = new msMap(document.getElementById('map_tag'),' ');
myMap.setCgi( 'http://myserver/myPHPMapscript.php ' );
myMap.setFullExtent( 5649512,5711778,6099485);
myMap.setMapFile( '/mymaps/example1.map' );
myMap.setLayers('countrys rivers sea');
myMap.redraw();
&lt;/script&gt;
&lt;/html&gt;
</pre>
<p>
Ok, I think that this is all :P. I hope I was clear enough but I encourage you to ask me if you have any doubt. 
</p>