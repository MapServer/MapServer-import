<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://mapserver.gis.umn.edu/mdp/docbkx412/docbookx.dtd">
<article>
	<articleinfo>
		<title>MapScript Reference</title>
		<author>
			<firstname>Jean-Fran&ccedil;ois</firstname>
			<surname>Doyon</surname>
			<affiliation>
				<orgname>Natural Resources Canada</orgname>
				<orgdiv>Earth Sciences Sector</orgdiv>
				<orgdiv>Canadian Center for Remote Sensing</orgdiv>
				<orgdiv>GeoAccess Division</orgdiv>
				<address>
					<email>jdoyon@nrcan.gc.ca</email>
				</address>
			</affiliation>
		</author>
		<abstract>
			<para>
    This document is a reference to the MapFile syntax for MapServer version 3.5.
    </para>
			<para>Last Updated:  7/19/2001</para>
		</abstract>
	</articleinfo>
  <sect1>
    <title>MapScript Reference</title>


    <para> MapScript is a scripting interface for the MapServer. It allows users to more easily build custom applications by hiding
    much of the complexity of the C API behind a simple object-oriented scripting interface. MapScript currently exists as a <ulink 
    href="http://www.perl.com/">Perl 5</ulink> module, but it could also made for <ulink url="http://www.tclconsortium.org">TK/TCL</ulink>, 
    <ulink url="http://www.python.org">Python</ulink> and <ulink url="http://java.sun.com/">Java</ulink>.
    </para>
    
    <para>
    The orginization of MapScript is very close to that of a <ulink url="mapfile-reference.html">map file</ulink>. It does <emphasis>not</emphasis> give you the
    functionality of the MapServer CGI program, rather it gives you the necessary pieces to build your own custom versions for use on the
    web or as standalone programs. Here's a simple perl example that loads a map file, creates an image and saves it
    </para>
    
      <programlisting>
      #!/usr/bin/perl

      use mapscript;

      $map = new mapObj('example.map) or die('Unable to open mapfile.');
      $img = $map->draw() or die('Unable to draw map');
      mapscript::msSaveImage($img, 'example.gif', $map->{interlace}, $map->{transparent});
      </programlisting>
  </sect1>
  
<!-- Changes -->  
  <sect1 id="changes">
    <title>Changes since MapServer 3.3</title>
    <para>
      Summarize Changes Here
    </para>
  </sect1>

<!-- USAGE -->  
  <sect1 id="usage">
    <title>Usage</title>
    <para>
      <emphasis>Perl</emphasis> - use mapscript;
    </para>
  </sect1>

<!-- CONSTANTS -->  
  <sect1 id="usage">
    <title>Constants</title>
    <para>
    Many <ulink url="mapfile-reference.html">map file</ulink> paramters take constant values. The following constants are available in MapScript.
    </para>
    
    <variablelist>
      <varlistentry>
	<term>boolean values</term>
	<listitem><para>MS_TRUE, MS_FALSE, MS_ON, MS_OFF, MS_YES, MS_NO</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>map units</term>
	<listitem><para>MS_INCHES, MS_FEET, MS_MILES, MS_METERS, MS_KILOMETERS, MS_DD</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>layer types</term>
	<listitem><para>MS_POINT, MS_LINE, MS_POLYGON, MS_POLYLINE, MS_RASTER, MS_ANNOTATION</para>
	</listitem>
      </varlistentry>
      
      <varlistentry>
        <term>font types</term>
	<listitem><para>MS_TRUETYPE, MS_BITMAP</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>label positions</term>
	<listitem><para>MS_UL, MS_LR, MS_UR, MS_LL, MS_CR, MS_CL, MS_UC, MS_LC, MS_CC, MS_AUTO</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>symbol set types</term>
	<listitem><para>MS_MARKERSET, MS_LINESET, MS_SHADESET</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>shapefile types</term>
	<listitem><para>MS_SHP_POINT, MS_SHP_ARC, MS_SHP_POLYGON, MS_SHP_MULTIPOINT</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term>query/join types</term>
	<listitem><para>MS_SINGLE, MS_MULTIPLE</para>
	</listitem>
      </varlistentry>
	
    </variablelist>
    <para>
    For example, in perl the syntax is $mapscript::MS_ON or $mapscript::MS_OFF.
    </para>
  </sect1>
  
  
    
<!-- CLASSES/OBJECTS -->    
  <sect1 id="class">   
  
    <title>Classes/Objects</title>
    
    <itemizedlist>
      <title>Access to the MapServer API is provided largely through a series classes. These classes allow the programmer to:</title>
      <listitem><para>manipulate virtually all aspects of a <ulink url="mapfile-reference.html">mapfile</ulink></para></listitem>
      <listitem><para>draw entire maps, layers or individual shapes</para></listitem>
      <listitem><para>perform spatial queries using points, areas or other features</para></listitem>
      <listitem><para>read/write shapefiles</para></listitem>
    </itemizedlist>
    
    <para>
    The main MapScript classes are given in the table below. Each class is described in detail later in this document.
    </para>
    
    <variablelist>

      <varlistentry>
	<term>mapObj</term>
	<listitem><para>holds all <ulink url="mapfile-reference.html">map file</ulink> parameters</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>layerObj</term>
	<listitem><para>holds all layer parameters, exists within a mapObj</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>classObj</term>
	<listitem><para>holds all class parameters, exists within a layerObj</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>featureObj</term>
	<listitem><para>holds attributes for a single inline feature, exists within a layerObj</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>queryResultObj</term>
	<listitem><para>holds the results of a spatial query (e.g. by point, area or feature)</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>pointObj</term>
	<listitem><para>simple class to hold a 2-D point</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>lineObj</term>
	<listitem><para>a lineObj is made up of pointObjs, may or may not be a closed ring</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>shapeObj</term>
	<listitem><para>a shapeObj is made up of lineObjs</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>rectObj</term>
	<listitem><para>class used to represent a 2-D rectangle, defined using minimum and maximum x and y coordinates</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>shapefileObj</term>
	<listitem><para>class used to access spatial information (i.e. features) stored in an <ulink url="http://www.esri.com">ESRI</ulink> shapefile</para>
	</listitem>
      </varlistentry>
        
      <varlistentry>
	<term>labelCacheMemberObj</term>
	<listitem><para>holds a single element from the label cache</para>
	</listitem>
      </varlistentry>    
 
    </variablelist>
<!-- MapObj -->
    <sect2 id="mapObj">
      <title>mapObj</title>
      <simplesect>
        <title>Constructor</title>
        <para>
          new mapObj(filename), for example <programlisting>$map = new mapObj('foo.map');</programlisting>. If the filename is undefined an 
	  empty mapObj is created and initialized.
        </para>
      </simplesect>
      
      <simplesect>
        <title>Members</title>      
      <para> See the <ulink url="mapfile-reference.html">map file</ulink> documentation for a list of parameters that can be changed. To get/set layer 
      parameters you'll need to use one of the methods defined below. Parameters that consist of a list (eg. size) can be accessed using
      individual list members- see below. All parameter names <emphasis>are</emphasis> to be given in lowercase. Only members not described via the map file 
      documentation will be detailed for any mapscript objects. There are no seperate objects defined for legends, reference maps or scalebars
      since all of their parameters can be accessed via a mapObj. SymbolSets and the fontSet are not available via MapScript yet.
      </para>
      
      <itemizedlist>
        <listitem><para> map, scalebar, and reference map <emphasis>size</emphasis> use <varname>height</varname> and <varname>width</varname> (eg. $map->{scalebar}->{width} = 250;)</para></listitem>    
        <listitem><para> map extent is actually a rectObj (see below)</para></listitem>
        <listitem><para> legend <emphasis>keysize</emphasis> use <varname>keysizex</varname> and <varname>keysizey</varname></para></listitem>
        <listitem><para> legend <emphasis>keyspacing</emphasis> use <varname>keyspacingx</varname> and <varname>keyspacingy</varname></para></listitem>
        <listitem><para> numlayers - number of layers in the map, read-only</para></listitem>
      </itemizedlist>
      
      <para>
      Here are some examples of member access:
      </para>
      
      <programlisting>
        $map->{extent}->{minx} = $minx;
        $map->{name} = 'test';
        $map->{scalebar}->{color} = $map->addColor($r, $g, $b);
        $map->{interlace} = $mapscript::MS_TRUE;
        $n = $map->{numlayers}; # numlayers is read-only
      </programlisting>
      
      </simplesect>
      
      <simplesect>     
        <title>Methods</title>
        <simplelist type="vert" columns="1">
          <member><replaceable>integer </replaceable><function>addColor(red, green, blue)</function> - Adds a color to maps palette, returns a color index. Color values can range from 0 to 255. 
           Must be called prior to running draw() or prepareImage().</member>

          <member><replaceable>image </replaceable><function>draw()</function> - renders a map, returns an image.</member>

          <member><replaceable>image </replaceable><function>drawQueryMap()</function> - renders a query map, returns an image.</member>

          <member><replaceable>integer </replaceable><function>drawLabelCache(image)</function> - renders the labels for a map. This is also done as part of the draw() method, but may need to called when 
           using other object draw methods. Returns -1 for failure.</member>

          <member><replaceable>image </replaceable><function>drawLegend()</function> - renders a legend, returns an image.</member>

          <member><replaceable>image </replaceable><function>drawReferenceMap()</function> - renders a reference map, returns an image.</member>

          <member><replaceable>image </replaceable><function>drawScalebar()</function> - renders a scalebar, return an image.</member>

          <member><replaceable>integer </replaceable><function>embedLegend()</function> - embeds a legend. Actually the legend is just added to the label cache so you must invoke drawLabelCache() 
           to actually do the rendering (unless postlabelcache is set).</member>

          <member><replaceable>integer </replaceable><function>embedScalebar()</function> - embeds a scalebar. Actually the scalebar is just added to the label cache so you must invoke 
           drawLabelCache() to actually do the rendering (unless postlabelcache is set).</member>

          <member><replaceable>layerObj </replaceable><function>getLayer(index)</function> - returns a layerObj given an index value. 0 returns first layer and so on. Total number of layers defined 
           in a map file is $map->{numlayers}.</member>

          <member><replaceable>layerObj </replaceable><function>getLayerByName(name)</function> - returns a layerObj given a layer name. 0 returns first layer and so on. Total number of layers 
           defined in a map file is $map->{numlayers}. If multiple layers exist with the same name the first occurance is returned.</member>

          <member><replaceable>integer </replaceable><function>getSymbolByName(type, name)</function> - returns the symbol index for a symbol of type MS_MARKERSET, MS_LINESET or MS_SHADESET given a 
           name. Returns -1 if the symbol is not found.</member>

          <member><replaceable>labelCacheMemberObj </replaceable><function>nextLabel()</function> - allows you to step through the label cache. One reason to do this would be to produce an imagemap 
           based on the annotation. Another would be to further post process a map by avoiding text. Returns a reference to a labelCacheMemberObj.</member>

          <member><replaceable>image </replaceable><function>prepareImage()</function> - initializes an image for drawing a map, return an image. Must be called prior to calling the draw methods 
           for other objects.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByPoint(point, type, buffer)</function> - queries a mapfile (i.e. a group of layers) using a point. Type is MS_SINGLE or 
           MS_MULTIPLE depending on how many results you want. Defaults to tolerances set in the mapfile but can use a constant buffer instead. 
           Returns queryResultObj.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByRect(rect)</function> - queries a mapfile (i.e. a group of layers) using a rectangle. Returns queryResultObj.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByFeature(results)</function> - queries a mapfile (i.e. a group of layers) using a another set of results. Returns 
           queryResultObj.</member>

          <member><replaceable>integer </replaceable><function>save(filename)</function> - Writes the contents of the mapfile to disk. Returns -1 for failure.</member>

          <member><replaceable>integer </replaceable><function>setProjection(parameters)</function> - Sets the projection and coordinate system for the map. Returns -1 for failure. Parameters 
           are given as a single string of comma delimited PROJ.4 parameters. For example, "proj=utm,ellps=GRS80,zone=15,north,no_defs".</member>
        </simplelist>   
	
	<para>    
        Here's an example that prints the string and bounding polygon(s) for all labels in the cache that are actually drawn:
	</para>
        <programlisting>
      while($label = $map->nextLabel()) {
        if($label->{status}) {
          print $label->{string} ."\n";

          $shape = $label->{poly};
          for($i=0; $i&lt;$shape->{numlines}; $i++) {
            $part = $shape->get($i);
            for($j=0; $j&lt;$part->{numpoints}; $j++) {
              $point = $part->get($j);
              print $point->{x} .",". $point->{y} ." ";
            }
            print "\n";
          }
        }
      }
        </programlisting>

 
      </simplesect> 
    </sect2>


<!-- layerObj -->
    <sect2>
      <title>layerObj</title>
      <simplesect>
        <title>Constructor:</title>
        <para>
        new layerObj(map), for example <programlisting>$layer = new layerObj($map);</programlisting> Normally you obtain layerObj from an existing layer within a map, however, 
        you can create a new layer (within a mapObj definition).
	</para>
      </simplesect>
      
      <simplesect>
        <title>Members (See the <ulink url="mapfile-reference.html">map file</ulink> documentation for a list of parameters that can be changed.)</title>
        <para> numclasses - number of classes in the layer, read-only</para>
      </simplesect>
      
      <simplesect>
        <title>Methods:</title>
        <simplelist type="vert" columns="1">
          <member><replaceable>classObj </replaceable><function>getClass(index)</function> - returns a classObj given an index value. 0 returns first class and so on. Total number of classes 
           defined in a layer is $class->{numclasses}.</member>

          <member><replaceable>integer </replaceable><function>draw(map, image)</function> - draws a single layer and adds labels to the cache if required. Returns 0 for success and -1 otherwise.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByPoint(map, point, type, buffer)</function> - queries a single layer using a point. Type is MS_SINGLE or MS_MULTIPLE 
           depending on how many results you want. Defaults to tolerances set in the mapfile but can use a constant (buffer) instead. Returns 
           queryResultObj.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByRect(map, rect)</function> - queries a single layer using a rectangle. Returns queryResultObj.</member>

          <member><replaceable>queryResultObj </replaceable><function>queryByFeature(map, results)</function> - queries a single layer using a another set of results. Returns queryResultObj.</member>

          <member><replaceable>integer </replaceable><function>setProjection(parameters)</function> - Sets the projection and coordinate system for the map. Returns -1 for failure. Parameters 
           are given as a single string of comma delimited PROJ.4 parameters. For example, "proj=utm,ellps=GRS80,zone=15,north,no_defs".</member>
        </simplelist>
      </simplesect>
    </sect2>
    
    
<!-- queryResultObj -->
    <sect2>
      <title>queryResultObj</title>
      <simplesect>  
      <title>Members</title>
        <simplelist type="vert" columns="1">
          <member> numresults - total number of matching records</member>
          <member> numquerylayers - total number of layers searched</member>
        </simplelist>
      </simplesect>
      
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
          <member><replaceable>shapeResultObj </replaceable><function>next()</function> - returns the next result record. Each record (shapeResultObj) contains 4 index values: layer (layer number), 
           tile (always -1 for now), shape (record number), and query (query number)</member>

          <member><function>free()</function> - free's memory associated with this result set. Since there is no constructor there is no deconstructor so you must call 
           this method or live with a memory leak.</member>
        </simplelist>
      </simplesect>
    </sect2>


<!-- classObj -->
    <sect2>
      <title>classObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
        new classObj(layer), for example $class = new classObj($layer);  - provides all access to all class parameters (color, symbol, label, etc...). 
	Normally you obtain a classObj from an existing class within a layer, however, you can create a new class (within a layer definition).
	</para>
      </simplesect>
      
      <simplesect>
        <title>Members (See the <ulink url="mapfile-reference.html">map file</ulink> documentation for a list of parameters that can be changed.)</title>
      </simplesect>
      
      <simplesect>
        <title>Methods</title> 
	<para>none</para>
      </simplesect>
    </sect2>

<!-- pointObj -->
    <sect2>
      <title>pointObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
          new pointObj(), for example <programlisting>$point = new pointObj();</programlisting>
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member> x - x coordinate</member>
          <member> y - y coordinate</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
          <member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - draws an individual point using layer. The class string is used to 
	  classify the point based on the classes defined for layer. The text string is used to annotate the point. Returns 0 for success and -1 otherwise.
	  </member>	
        </simplelist>
      </simplesect>
    </sect2>
    
    
<!-- lineObj -->    
    <sect2>
      <title>lineObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
          new lineObj(), for example <programlisting>$line = new lineObj();</programlisting>
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member>numlines - number of lines (i.e. parts) in this shape, read-only</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
	  <member><function>add(point)</function> - adds a point to the end of a line.</member>
        </simplelist>
      </simplesect>      
    </sect2>
      
    
<!-- shapeObj -->    
    <sect2>
      <title>shapeObj</title>
       <simplesect>
        <title>Constructor</title> 
        <para>
         new shapeObj(type), for example <programlisting>$shape = new shapeObj($mapscript::MS_POLYGON);</programlisting>
	</para>
	
	<para>
        The type parameter is just a general type used to make MapScript less bulky. With
        it MapScript can make decisions in a few comparision methods (eg. contains or intersects)
        without having to have a bunch of type specific methods. Type is not used in any other
        way right now, so often a value of -1 should suffice. Other valid values are: MS_POINT,
        MS_LINE and MS_POLYGON. Other shape creation methods (see shapefileObj) populate this
        parameter correctly.
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member> bounds - a rectObj containing the shapes bounding box, if available</member>
          <member> numlines - number of lines (i.e. parts) in this shape, read-only</member>
          <member> type - generic type (MS_POINT, MS_LINE, MS_POLYGON) of this shape</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
          <member><function>add(line)</function> - adds a line to the shape.</member>
          <member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - draws an individual shape using layer. The class string is used to 
	  classify the point based on the classes defined for layer. The text string is used to annotate the shape. Returns 0 for success and -1
	  otherwise.</member>
        </simplelist>
      </simplesect>           
    </sect2>
    
    
     
<!-- featureObj -->    
    <sect2>
      <title>featureObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
          new featureObj(layer), for example <programlisting>$feature = new featureObj($layer);</programlisting>
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member>class - used to classify the feature if multiple classes are defined for layer</member>
          <member>text - used to annotate the feature</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
	  <member><function>add(line)</function> - adds a line to the feature.</member>
        </simplelist>
      </simplesect>      
    </sect2>     
    
    
    
<!-- rectObj -->    
    <sect2>
      <title>rectObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
          new rectObj(), for example <programlisting>$rect = new rectObj();</programlisting>
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member>minx, miny, maxx, maxy</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
	  <member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - draws an individual rectangle using layer. The class string is used to classify 
           the point based on the classes defined for layer. The text string is used to annotate the rectangle. Returns 0 for success and -1 
           otherwise.</member>
          <member><replaceable>double  </replaceable><function>fit(height, width)</function> - adjusts a rectangle (eg. an extent) to fit an image size. The 
	  cellsize (in map units) is returned.</member>
        </simplelist>
      </simplesect>      
    </sect2>           
      
      
      
<!-- shapefileObj -->    
    <sect2>      
    <title>shapefileObj</title>
      <simplesect>
        <title>Constructor</title> 
        <para>
        new shapefileObj(filename, type), for example <programlisting>$shapefile = new shapeObj('lakes');</programlisting> No extension is necessary. For existing files type should be -1, to create an empty file set type to one of: MS_SHP_POINT,
        MS_SHP_ARC, MS_SHP_POLYGON, or MS_SHP_MULTIPOINT. To close a shapefile you've been writing to you need to undefine the perl reference (i.e. undef $shapefile; or $shapefile = '';).
	</para>
      </simplesect>  
          
      <simplesect>  
        <title>Members</title>
        <simplelist type="vert" columns="1">
          <member>numshapes - number of shapes in the shapefile, read-only</member>
          <member>type - type of shapefile, read-only</member>
          <member>bounds - a rectObj containing the shapefiles bounding box</member>
        </simplelist>
      </simplesect>
      
      <simplesect>
        <title>Methods</title>
        <simplelist type="vert" columns="1">
          <member><function>get(index, shape)</function> - retrieves a shape by index.</member>
          <member><function>getExtent(index, rect)</function> - retrieves a shape's bounding box by index.</member>
          <member><function>add(shape)</function> - appends a shape to an open shapefile.</member>
        </simplelist>
      </simplesect>    
    </sect2>
    
<!-- MISCELANEOUS FUNCTIONS -->    
    <sect2>        
      <title>Miscelaneous Functions</title>
      <para>
        MapScript supports a few miscelaneous functions for image handling. They are:
      </para>
      <simplelist>
        <member><function>msSaveImage(image, filename, transparent, interlace)</function> - saves an image to a file. Set filename to undef to save to stdout. The 
         transparent and interlace flags are boolean values.</member>
        <member><function>msFreeImage(image)</function> - free the memory associated with an image.</member>
      </simplelist>
    </sect2>
  </sect1>
  
  
<!-- ERROR HANDLING -->
  <sect1>
    <title>Error Handling</title>
  </sect1>

</article>

