<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
          "http://mapserver.gis.umn.edu/mdp/docbkx412/docbookx.dtd">
<!-- $Id$ -->
<article>
  <articleinfo>
    <!-- insert title here, include the word HOWTO -->
    <title>HOWTO for Rasters in MapServer 4.4</title>
    <author>
      <firstname>Frank</firstname>
      <surname>Warmerdam</surname>
      <affiliation>
        <orgname>DM Solutions Group Inc.</orgname>
        <address>
          <email>warmerdam@pobox.com</email>
        </address>
      </affiliation>
    </author>
    <date>2003-09-25</date>
    <abstract>
      <!-- a short description of the contents of the doc -->
      <para>
                 This document describes the procedures for using raster data within MapServer applications.
               </para>
      <para>Last Updated: $Date$</para>
            <para><link linkend='rhistory'>Revision History</link></para>
    </abstract>
  </articleinfo>

<!-- ********************************************************************** -->
     
<sect1 id="intro">  <title>Introduction</title>
    
<para>
    MapServer supports rendering a variety of raster file formats
    in maps.  The following describes some of the supported formats,
    and what capabilities are supported with what formats.
</para>
<para>
This document assumes that you are already familiar with setting up MapServer
map files, but does explain the raster specific aspects of map files. 
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="definition">  <title>How are rasters added to a Map file?</title>

<para>
A simple raster layer declaration looks like this.  The DATA file is
interpreted relative to the SHAPEPATH, much like shapefiles.  
</para>

<para>
<programlisting>
LAYER
  NAME "JacksonvilleNC_CIB"
  DATA "Jacksonville.tif"
  TYPE RASTER
  STATUS ON
END
</programlisting>
</para>

<para>
Though not shown rasters can have PROJECTION, METADATA, PROCESSING, MINSCALE, 
and MAXSCALE information.  It cannot have labels, CONNECTION, 
CONNECTIONTYPE, or FEATURE information.  
</para>
</sect1>

<!-- ====================================================================== -->

<sect1 id="classify">  <title>Classifying Rasters</title>

<para>
Rasters can be classified in a manner similar to vectors, with a few
exceptions.  
</para>

<para>There is no need to specify a CLASSITEM.  The raw pixel value itself
("[pixel]") and, for paletted images, the red, green and blue color 
associated with that pixel value ("[red]", "[green]" and "[blue]") are
available for use in classifications.  When used in an evaluated expression
the pixel, red, green and blue keywords must be in lower case.
</para>

<programlisting>
LAYER
  NAME "JacksonvilleNC_CIB"
  DATA "Jacksonville.tif"
  TYPE RASTER
  STATUS ON
  CLASSITEM "[pixel]"
  # class using simple string comparison, equivelent to ([pixel] = 0)
  CLASS
    EXPRESSION "0"
    COLOR 0 0 0
  END
  # class using an EXPRESSION using only [pixel]. 
  CLASS
    EXPRESSION ([pixel] &gt;= 64 AND [pixel] &lt; 128)
    COLOR 255 0 0 
  END
  # class using the red/green/blue values from the palette
  CLASS
    NAME "near white"
    EXPRESSION ([red] > 200 AND [green] > 200 AND [blue] > 200)
    COLOR 0 255 0 
  END
  # Class using a regular expression to capture only pixel values ending in 1
  CLASS
    EXPRESSION /*1/
    COLOR 0 0 255
  END
END
</programlisting>

<para>
As usual, CLASS definitions are evaluated in order from first to last, and
the first to match is used.  If a CLASS has a NAME attribute it may appear
in a LEGEND.  Only the COLOR, EXPRESSION and NAME parameters within a 
CLASS definition are utilized for raster classifications.  The other styling 
or control information is ignored.
</para>

<para>
Raster classifications always take place on only one raster
band.  It defaults to the first band in the referenced file, but this can
be altered with the BANDS PROCESSING directive.  In particular this means
that including even a single CLASS declaration in a raster layer will result
in the raster layer being rendered using the one band classification rules 
instead of other rules that might have applied (such as 3 band RGB rendering).
</para>

<sect3><title>Classifying Non-8bit Rasters</title>

<para>
As of MapServer 4.4 support has been added for classifying non-8bit raster
inputs.  That is input rasters with values outside the range 0-255.  Mostly
this works transparently but there are a few caveats and options to provide
explicit control.
</para>

<para>
Classifying raster data in MapServer is accomplished by pre-classifying all
expected input values and using that table of classification results to lookup
each pixel as it is rendered.  This is done because evaluating a pixel
value against a series of CLASS definitions is relatively expensive to do 
for the hundreds of thousands of pixels in a typical rendered image.
</para>

<para>
For simple 8bit inputs, only 256 input values need to be pre-classified.  But
for non-8bit inputs more values need to be classified.  For 16bit integer
inputs all 65536 possible input values are pre-classified.  For floating 
point and other input data types, up to 65536 values are pre-classified based
on the maximum expected range of input values. 
</para>

<para>
The PROCESSING directive can be used to override the range of values to be
pre-classified, or the number of values (aka Buckets) in that range to 
classify.  The SCALE=min,max PROCESSING directive controls the range.  The
SCALE_BUCKETS PROCESSING directive controls the number of buckets.   In some
cases rendering can be accelerated considerable by selecting a restricted range
of input values and a reduced number of scaling values (buckets). 
</para>

<para>
The following example classifies a floating raster, but only 4 values over
the range -10 to 10 are classified.  In particular, the values classified
would be -7.5, -2.5, 2.5, and 7.5 (the middle of each "quarter" of the range). 
So those four value are classified, and one of the classification results is
selected based on which value is closest to the pixel value being classified.
</para>

<programlisting>
LAYER
  NAME grid1
  TYPE raster
  STATUS default
  DATA data/float.tif
  PROCESSING "SCALE=-10,10"
  PROCESSING "SCALE_BUCKETS=4"
  CLASS 
    NAME "red"
    EXPRESSION ([pixel] &lt; -3)
    COLOR 255 0 0 
  END
  CLASS 
    NAME "green"
    EXPRESSION ([pixel] >= -3 and [pixel] &lt; 3)
    COLOR 0 255 0
  END
  CLASS 
    NAME "blue"
    EXPRESSION ([pixel] >= 3)
    COLOR 0 0 255
  END
END
</programlisting>

</sect3>

</sect1>

<!-- ====================================================================== -->

<sect1 id="formats">  <title>Supported Formats</title>

<para>
What raster formats are supported by MapServer is largely controlled by
configuration time options.  Some formats are considered to be <emphasis>
built-in</emphasis> while the remainder are handled by the optional
GDAL raster library.  
</para>

<para>
More information on GDAL can be found at <ulink 
url="http://www.gdal.org/">http://www.gdal.org</ulink>, including the 
<ulink url="http://www.gdal.org/formats_list.html">supported formats 
list</ulink>.  Some of the advanced MapServer
raster features, such as resampling, RGB color cube generation and automatic
projection capture only work with raster formats used through GDAL.  GDAL 
is normally built and installed separately from MapServer, and then enabled
during the build of MapServer using the <emphasis>--with-gdal</emphasis>
configuration switch.  
</para>

<para>
To find out what is built into a particular MapServer executable, use the
-v flags to discover what build options are enabled.  To find out what 
gdal formats are available, the "gdalinfo --formats" command may be used.  For 
example:
</para>

<programlisting>
warmerda@gdal2200[124]% mapserv -v
MapServer version 4.4.0-beta2 OUTPUT=GIF OUTPUT=PNG OUTPUT=JPEG OUTPUT=WBMP 
SUPPORTS=PROJ SUPPORTS=FREETYPE SUPPORTS=WMS_SERVER SUPPORTS=WMS_CLIENT 
SUPPORTS=WFS_SERVER SUPPORTS=WFS_CLIENT SUPPORTS=WCS_SERVER SUPPORTS=FASTCGI 
INPUT=EPPL7 INPUT=POSTGIS INPUT=OGR INPUT=GDAL INPUT=SHAPEFILE DEBUG=MSDEBUG
warmerda@gdal2200[18]% gdalinfo --formats
Supported Formats:
  GRASS (ro): GRASS Database Rasters (5.7+)
  GTiff (rw+): GeoTIFF
  NITF (rw+): National Imagery Transmission Format
  HFA (rw+): Erdas Imagine Images (.img)
  SAR_CEOS (ro): CEOS SAR Image
  ...
</programlisting>

<para>
The following formats are potential builtins.
</para>

<itemizedlist>
  <listitem>
    <para><emphasis>TIFF/GeoTIFF</emphasis>: 
      If built with <emphasis>INPUT=TIFF</emphasis> MapServer will have
      builtin support for reading TIFF or GeoTIFF files.  The builtin 
      TIFF support has some limitations with regard to the organization of
      files that can be read (no tiled, 16bit, RGB, or odd color models). 
      This driver supports <ulink url="#world_files">world files</ulink>, 
      or simple builtin GeoTIFF coordinates for georeferencing.
    </para>
    <para>
      Full featured TIFF/GeoTIFF support is available through GDAL.  Note
      that only GDAL supports tiled TIFF files and TIFF files with overviews.
      Tiled TIFF files with overviews pre-built are one of the highest 
      performance ways of serving large raster images.
    </para>
  </listitem>

  <listitem>
    <para><emphasis>GIF</emphasis>: 
      If GD is configured with GIF (<emphasis>OUTPUT=GIF</emphasis>) support, 
      then MapServer will also be able
      to read GIF files for raster layers.  The only way to georeference GIF
      files is with a world file.
    </para>
    <para>
      If GD is not configured with GIF support, it may still be available in
      GDAL.  
    </para>
  </listitem>
  <listitem>
    <para><emphasis>PNG</emphasis>: 
      If GD is configured with PNG (<emphasis>OUTPUT=PNG</emphasis>) support, 
      then MapServer will also be able
      to read PNG files for raster layers.  The only way to georeference PNG
      files is with a world file.
    </para>
    <para>
      If GD is not configured with PNG support, it may still be available in
      GDAL. 
    </para>
  </listitem>
  <listitem>
    <para><emphasis>JPEG</emphasis>: 
      If MapServer is built with JPEG (<emphasis>INPUT=JPEG</emphasis>) 
      support then greyscale
      JPEG files may be rendered in raster layers.  RGB files (the more common 
      kind) will not be able to be displayed.  Georeferencing is via world 
      files.
    </para>
    <para>
      If MapServer is not built with native JPEG support, GDAL may still 
      support the format.  In this case RGB files are also supported (via
      the RGB color cube mechanism).  Georeferencing is still via world file.
    </para>
  </listitem>
  <listitem>
    <para><emphasis>Erdas .LAN/.GIS</emphasis>: 
      If configured with <emphasis>INPUT=EPPL7</emphasis> (the default) 
      MapServer will support one band eight bit Erdas LAN/GIS files.  The 
      .trl file is read for a colormap, and if not found the layer is treated 
      as greyscale.  Georeferencing is read from the file. 
    </para>
  </listitem>
  <listitem>
    <para><emphasis>SDE Raster</emphasis>: 
      If configured with <emphasis>INPUT=SDE</emphasis>.  MapServer support
      for SDE raster data is new for 4.4 and still experimental.  See the
      SDE HOWTO for details on how to define an SDE Raster layer.
    </para>
  </listitem>
</itemizedlist>

<para>
If MapServer is built with GDAL it is generally better to access all possible
formats through GDAL rather than via the built-in drivers.   The built-in
drivers are less featureful, and not as well maintained.
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="indexing">  <title>Rasters and Tile Indexing</title>

<para>
When handling very large raster layers it is often convenient, and higher
performance to split the raster image into a number of smaller images.  Each
file is a tile of the larger raster mosaic available for display.  The list
of files forming a layer can be stored in a shapefile with polygons 
representing the footprint of each file, and the name of the files.  This is
called a TILEINDEX and works similarly to the same feature in vector layers. 
The result can be represented in the MAP file as one layer, but MapServer 
will first scan the tile index, and ensure that only raster files overlapping
the current display request will be opened.
</para>

<para>
The following example shows a simple example.  No DATA statement is required
because MapServer will fetch the filename of the raster files from the
Location attribute column in the hp2.dbf file for records associated with
polygons in hp2.shp that intersect the current display region.  The polygons
in hp2.shp should be rectangles representing the footprint of the corresponding
file.  Note that the files do not have to be all the same size, the formats
can vary and they can even
overlap (later files will be drawn over earlier ones); however, they must all
be in the same coordinate system (projection) as the layer.
</para>

<programlisting>
  LAYER
    NAME "hpool"
    STATUS ON
    TILEINDEX "hp2.shp"
    TILEITEM "Location"
    TYPE RASTER
  END
</programlisting>

<para>
While there are many ways to produce TILEINDEX shapefiles for use with this
command, one option is the <emphasis>gdaltindex</emphasis> program, part of
the GDAL utility suite.  The gdaltindex program will automatically generate
a tile index shapefile from a list of GDAL supported raster files passed on
the command line.
</para>

<programlisting>
Usage: gdaltindex [-tileindex field_name] index_file [gdal_file]*

eg.
  % gdaltindex doq_index.shp doq/*.tif

NOTES:
  o The shapefile (index_file) will be created if it doesn't already exist.
  o The default tile index field is 'location'.
  o Raster filenames will be put in the file exactly as they are specified
    on the commandline.
  o Simple rectangular polygons are generated in the same
    coordinate system as the rasters.
</programlisting>

<para>
The gdaltindex program is built as part of GDAL.  Prebuilt binaries for GDAL
including the gdaltindex program can be downloaded as part of the 
<ulink url="http://fwtools.maptools.org/">FWTools</ulink> distribution.
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="warping">  <title>Raster Warping</title>

<para>
MapServer is able to resample GDAL rasters on the
fly into new projections.  Non-GDAL rasters may only be up or down
sampled without any rotation or warping.
</para>

<para>
Raster warping kicks in if the projection appears to be different for a 
raster layer than for the map being generated.  Warped raster layers are 
significantly more expensive to render than normal raster layers with 
rendering time being perhaps 2-4 times long than a normal layer.  The
projection and datum shifting transformation is computed only at selected
points, and generally linearly interpolated along the scanlines (as long as
the error appears to be less than 0.333 pixels. 
</para>

<para>
In addition to reprojecting rasters, the raster warping ability can also
apply rotation to GDAL rasters with rotational coefficients in their
georeferencing information.   Currently rotational coefficients won't 
trigger raster warping unless the map and layer have valid (though matching
is fine) projection definitions. 
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="rgb_color_cube">  <title>24bit RGB Rendering</title>

<para>
Traditionally MapServer has been used to produce 8 bit pseudo-colored
map displays generated from 8bit greyscale or pseudocolored raster data. 
However, if the raster file to be rendered is actually 24bit (a red, 
green and blue band) then additional considerations come into play.   
Currently rendering of 24bit imagery is only supported via the GDAL 
renderer.  The built-in PNG, JPEG and other drivers do not support 24bit
input images. 
</para>

<para>
If the output is still 8bit pseudo-colored (the IMAGEMODE is PC256 in the
associated OUTPUT format declaration) then the full 24bit RGB colors for
input pixels will be converted to a color in the colormap of the output 
image.  By default a <emphasis>color cube</emphasis> is used.  That is a
fixed set of 175 colors providing 5 levels of red, 7 levels of green and
5 levels of blue is used, plus an additional 32 greyscale color entries. 
Colors in the input raster are mapped to the closest color in this color
cube on the fly.  This substantial degrades color quality, especially for
smoothly changing images.   It also fills up the colors table, limited to
256 colors, quite quickly.
</para>

<para>
A variation on this approach is to dither the image during rendering. 
Dithering selects a color for a pixel in a manner that "diffuses error"
over pixels.  In an area all one color in the source image, a variety of output
pixel colors would be selected such that the average of the pixels would more
closely approximate the desired color.  Dithering also takes advantage of all
currently allocated colors, not just those in the color cube.  Dithering 
requires GDAL 1.1.9 or later, and is enabled by providing the 
PROCESSING "DITHER=YES" option in the mapfile.   Dithering is more CPU
intensive than using a simple color cube, and should be avoided if possible
in performance sensitive situations.
</para>

<para>
The other new possibility for handling 24bit input imagery in MapServer 4.0
or later, is to produce 24bit output images.  The default "IMAGETYPE png24"
or "IMAGETYPE jpeg" declaration may be used to produce a 24bit PNG output 
file, instead of the
more common 8bit pseudo-colored PNG file.  The OUTPUTFORMAT declaration
provides for detailed control of the output format.  The IMAGEMODE RGB and
IMAGEMODE RGBA options produce 24bit and 32bit (24bit plus 8bit 
alpha/transparency) for supported formats.
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="processing">  <title>Special Processing Directives</title>

<para>
In MapServer 4, the new PROCESSING keyword was added to the LAYER object.
It is primariliy used to pass specialized raster processing options to the
GDAL based raster renderer.  The following processing options are supported
in MapServer 4.
</para>

<variablelist>
    <varlistentry>
      <term>DITHER=YES</term>
      <listitem>
  <para>This turns on error diffusion mode, used to convert 24bit images
to 8bit with error diffusion to get better color results.</para>
  <para>Example:
      <screen>
PROCESSING "DITHER=YES"
      </screen>
  </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>BANDS=red_or_grey[,green,blue[,alpha]]</term>
      <listitem>
  <para>This directive allows a specific band or bands to be selected from a raster file.  If one band is selected, it is treated as greyscale.  If 3 are selected, they are treated as red, green and blue.  If 4 are selected they are treated as red, green, blue and alpha (opacity).</para>
  <para>Example:
      <screen>
PROCESSING "BANDS=4,2,1"
      </screen>
  </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>SCALE[_n]=AUTO or min,max</term>
      <listitem>
  <para>This directive instructs the GDAL reader to pre-scale the 
incoming raster data.  It is primarily used to scale 16bit or floating point 
data to the range 0-255, but can also be used to constrast stretch 8bit data.  
If an explicit min/max are provided then the input data is stretch (or 
squished) such that the minimum value maps to zero, and the maximum to 255. 
If AUTO is used instead, a min/max is automatically computed.  To control the
scaling of individual input bands, use the SCALE_1, SCALE_2 and SCALE_3 
keywords (for red, green and blue) instead of SCALE which applies to all bands.
</para>

  <para>Example:
      <screen>
PROCESSING "SCALE=AUTO"
  or
PROCESSING "SCALE_1=409,1203"
PROCESSING "SCALE_2=203,296"
PROCESSING "SCALE_3=339,1004"
      </screen>
  </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>COLOR_MATCH_THRESHOLD=n</term>
      <listitem>
  <para>Alter the precision with which colors need to match an entry in 
the color table to use it when producing 8bit colormapped output (IMAGEMODE 
PC256).  Normally colors from a raster colormap (or greyscale values) need
to match exactly.  This relaxes the requirement to being within the 
specified color distance.   So a COLOR_MATCH_THRESHOLD of 3 would mean that an
existing color entry within 3 (sum of difference in red, green and blue) would
be used instead of creating a new colormap entry.  Especially with greyscale
raster layers, which would normally use all 256 color entries if available, 
this can be a good way to avoid "stealing" your whole colormap for a raster
layer.  Normally values in the range 2-6 will give good results. 
</para>
  <para>Example:
      <screen>
PROCESSING "COLOR_MATCH_THRESHOLD=3"
      </screen>
  </para>
      </listitem>
    </varlistentry>

</variablelist>

</sect1>

<!-- ====================================================================== -->

<sect1 id="query">  <title>Raster Query</title>

<para>
A new feature of MapServer 4.4 is the ability to perform queries on rasters
in a manner similar to queries against vector layers.  Raster queries on
raster layers return one point feature for each pixel matching the query.
The point features will have attributes indicating the value of different
bands at that pixel, the final rendering color and the class name.  The
resulting feature can be directly access in MapScript, or processed through
templates much like normal vector query results.  Only raster layers with
a query TEMPLATE associated can be queried, even for the query methods that
don't actually use the query template (much like vector data). 
</para>

<para>
Raster query supports QueryByPoint, QueryByRect, and QueryByShape.  
QueryByPoint supports single and multiple result queries.  Other query 
operations such as QueryByIndex, QueryByIndexAdd, QueryByAttributes and
QueryByFeature are not supported for raster layers.  Raster layers do not
support saving queries to disk, nor query maps.
</para>

<para>
Raster queries return 
point features with some or all of the following attributes.
</para>

<variablelist>
  <varlistentry>
    <term>x</term>
    <listitem>
      <para>georeferenced X location of pixel.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>y</term>
    <listitem>
      <para>georeferenced Y location of pixel.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>value_list</term>
    <listitem>
      <para>a comma separated list of the values of all selected bands at 
            the target pixel. </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>value_<emphasis>n</emphasis></term>
    <listitem>
      <para>the value for the n'th band in the selected list at this pixel (zero based).  There is one value_<emphasis>n</emphasis> entry for each selected band.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>class</term>
    <listitem>
      <para>Name of the class this pixel is a member of (classified layers only).</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>red</term>
    <listitem>
      <para>red component of the display color for this pixel.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>green</term>
    <listitem>
      <para>green component of the display color for this pixel.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>blue</term>
    <listitem>
      <para>blue component of the display color for this pixel.</para>
    </listitem>
  </varlistentry>
</variablelist>

<para>
The red, green and blue attribute are intended to be the final color the pixel
would be rendered with, but in some subtle cases it can be wrong (ie. 
classified floating point results).  The selected bands are normally the 
band that would be used to render the layer.  For a pure query-only layer 
BANDS PROCESSING directive can be used to select more bands than could normally
be used in a render operation.  For instance for a 7 band landsat scene a
PROCESSING "BANDS=1,2,3,4,5,6,7" directive could be used to get query results
for all seven bands in results to a query operation.
</para>

<para> 
Care should be taken to avoid providing a large query area (selecting alot of pixels) as each selected pixel requires over 100 bytes of memory for temporary caching. The RASTER_QUERY_MAX_RESULT PROCESSING item can be used to restrict the maximum number of query results that will be returned. The default is one million which would take on the order of 100MB of RAM.
</para>

<para>
Query results can be returned as HTML via the normal substitution into 
query template HTML. Query results are also accessable via WMS GetFeatureInfo
calls, and from MapScript.  The following example shows executing a feature
query from Python MapScript and fetching back the results. 
</para>

<programlisting>
  map = mapscript.Map('rquery.map')
  layer = map.getLayer(0)

  pnt = mapscript.Point()
  pnt.x = 440780
  pnt.y = 3751260
    
  layer.queryByPoint( map, pnt, mapscript.MS_MULTIPLE, 180.0 )

  layer.open()
  for i in range(1000):
    result = layer.getResult( i )
    if result is None:
      break
        
    print '(%d,%d)' % (result.shapeindex, result.tileindex)
        
    s = layer.getShape( result.shapeindex, result.tileindex )
    for i in range(layer.numitems):
      print '%s: %s' % (layer.getItem(i), s.getValue(i))
            
layer.close()
</programlisting>

<para>
This is a simple example query TEMPLATE file. The raster pixel attributes
will be substituted in before the query result is returned to the user
as HTML.
</para>

<programlisting>
Pixel:&lt;br>
  values=[value_list]&lt;br>
  value_0=[value_0]&lt;br>
  value_1=[value_1]&lt;br>
  value_2=[value_2]&lt;br>
  RGB = [red],[green],[blue]&lt;p>
  Class = [class]&lt;br>
</programlisting>

<para>
Internally raster query results are essentially treated as a set of 
temporary features cached in RAM.  Issuing a new query operation clears
the existing query cache on the layer.  The transitory in-memory 
representation of raster query results is also responsible for the inability
to save raster query results since saved query results normally only contain
the feature ids, not the entire features.    Some addition information is
available in the 
<ulink url="http://mapserver.gis.umn.edu/cgi-bin/wiki.pl?RasterQuery">RasterQuery</ulink> Wiki topic.
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="preprocessing">  <title>Preprocessing Rasters</title>


<para>
<emphasis>Eventually I should add some general information on how to 
preprocess raster data for optimal use in MapServer, and give specific 
information on how to use GDAL's rgb2pct.py, gdaladdo and gdal_translate to 
converting stuff into pseudocolored, tiled GeoTIFF files with overviews.
</emphasis>
</para>

</sect1>

<!-- ====================================================================== -->

<sect1 id="performance">  <title>Raster Display Performance Tips</title>

<itemizedlist>

<listitem>
<para>
Build overview levels for large rasters to ensure only a reasonable amount of
data needs to be touched to display an overview of a large layer.  Overviews
can be implemented as a group of raster layers at different resolutions, using
MINSCALE, and MAXSCALE to control which layers are displayed at different
resolutions.  Another, perhaps easier way, is to build overviews for GDAL
supported formats using the gdaladdo utility.
</para>
</listitem>

<listitem>
<para>
Preprocess RGB images to eightbit with a colormap to reduce the amount of
data that has to be read, and the amount of computation to do on the fly.
</para>
</listitem>

<listitem>
<para>
For large images use tiling to reduce the overhead for loading a view
of a small area.  This can be accomplished using the TILEINDEX mechanism
of the mapfile, or by creating a tiled format file (ie. TIFF with GDAL). 
</para>
</listitem>

<listitem>
<para>
Ensure that the image is kept on disk in the most commonly requested 
projection to avoid on-the-fly image warping which is fairly expensive. 
</para>
</listitem>

<listitem>
<para>
If you are getting debug output from MapServer in your web server log file,
check to see if the message <emphasis>msResampleGDALToMap in effect</emphasis>
appears.  If so, the raster layer is being resampled.  If you don't think it
should be resampled carefully review your map file to ensure that the layer
projection <emphasis>exactly</emphasis> matches the map projection or that 
the layer has no projection definition.
</para>
</listitem>

</itemizedlist>
</sect1>

<!-- ====================================================================== -->

<sect1 id="world_files">  <title>Georeference with World Files</title>

<para>
World files are a simple mechanism for associating georeferencing (world
coordinates) information with raster files.  ESRI was the first company to
propagate the use of world files, and they often used with TIFF instead
of embedding georeferencing information in the file itself.  
</para>

<para>
The world file contents look like the following.  The first coefficient is
the X pixel size.  The second and third are rotational/shear coefficients 
(and should normally be 0.0).  The fourth is the Y pixel size, normally 
negative indicating that Y decreases as you move down from the top left 
origin. The final two values are the X and Y location of the center of the 
top left pixel.  This example is for an image with a 2m x 2m pixel size, and 
a top left origin at (356800E, 5767999N). 
</para>

<programlisting>
2
0.0000000000
0.0000000000
-2
356800.00
5767999.00
</programlisting>

<para>
The name of the world file is based on the file it relates to.  For instance,
the world file for aerial.tif might be aerial.tfw.  Conventions vary for
appropriate endings, but with MapServer the extension .wld is always OK
for world files. 
</para>

</sect1>

<!-- ********************************************************************** -->
     
  <!-- Section1: Document Info -->
  <sect1 id="docinfo">
    <title>About This Document</title>
    <sect2 id="copyright">
      <title>Copyright Information</title>
      <para>
                Copyright (c) 2004, Frank Warmerdam, DM Solutions Group Inc.
            </para>
      <para>
                This documentation is covered by the same Open Source license as the
                MapServer software itself.  See MapServer's 
                <ulink url="http://mapserver.gis.umn.edu/license.html">License and 
                Credits</ulink> page for the complete text.
            </para>
    </sect2>
    <sect2 id="disclaimer">
      <title>Disclaimer</title>
      <para>
            No liability for the contents of this document can be accepted.
            Use the concepts, examples and other content at your own risk.
            As this is a new edition of this document, there may be errors
            and inaccuracies that may be damaging to your system.
            Although this is highly unlikely, the author(s) do not take any 
            responsibility for that:  proceed with caution.
                  </para>
    </sect2>
    <!-- Section2: feedback -->
    <sect2 id="feedback">
      <title>Feedback</title>
      <para>
            Send any comments or suggestions to the author.
        </para>
    </sect2>

<!-- ********************************************************************** -->

<!-- Revision History -->

  <sect2 id='rhistory'><title>Document Changes</title>
  <para>
     <revhistory>
      <revision>
        <revnumber>: 1.14</revnumber>
        <date>Date: 2004/11/16</date>
        <authorinitials>Author: Frank Warmerdam</authorinitials>
        <revremark>Added raster query, various other 4.4 updates.</revremark>
      </revision>     
      <revision>
        <revnumber>: 1.12</revnumber>
        <date>Date: 2004/10/31</date>
        <authorinitials>Author: Jeff McKenna</authorinitials>
        <revremark>Fixed anchor for indexing section.</revremark>
      </revision>     
      <revision>
        <revnumber>: 1</revnumber>
        <date>Date: 2004/02/02</date>
        <authorinitials>Author: Frank Warmerdam</authorinitials>
        <revremark>I added the Revision History section to this document.</revremark>
      </revision>
     </revhistory>
  </para>
  </sect2>

  </sect1>

</article>
