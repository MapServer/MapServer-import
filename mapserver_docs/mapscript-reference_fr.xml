<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://mapserver.gis.umn.edu/mdp/docbkx412/docbookx.dtd">
<article>
	<articleinfo>
		<title>Référence MapScript</title>
		<author>
			<firstname>Jean-François</firstname>
			<surname>Doyon</surname>
			<affiliation>
				<orgname>Natural Resources Canada</orgname>
				<orgdiv>Earth Sciences Sector</orgdiv>
				<orgdiv>Canadian Center for Remote Sensing</orgdiv>
				<orgdiv>GeoAccess Division</orgdiv>
				<address>
					<email>jdoyon@nrcan.gc.ca</email>
				</address>
			</affiliation>
		</author>
		<othercredit>
			<contrib>Traduction</contrib>
			<firstname>Franz-Albert</firstname>
			<surname>Van Den Bussche</surname>
			<affiliation>
				<orgname>Club des Utilisateurs de Linux et des logiciels libres de Toulouse et des environs</orgname>
				<orgdiv>CULTe</orgdiv>
				<address>
					<email>franz@favdb.net</email>
				</address>
			</affiliation>
		</othercredit>
		<othercredit>
			<contrib>Relecture</contrib>
			<firstname>Nathalie</firstname>
			<surname>Vielmas</surname>
			<affiliation>
				<orgname>Club des Utilisateurs de Linux et des logiciels libres de Toulouse et des environs</orgname>
				<orgdiv>CULTe</orgdiv>
				<address>
					<email>nath31@ifrance.com</email>
				</address>
			</affiliation>
		</othercredit>
		<abstract>
			<para>Ce document est un document de référence pour MapScript pour MapServer version 3.5.
    </para>
			<para>Dernière mise à jour:  19/07/2001</para>
		</abstract>
	</articleinfo>
	<sect1>
		<title>Référence MapScript</title>
		<para> MapScript est l'interface de script pour MapServer. Il permet aux utilisateurs de construire plus facilement des applications personnalisées en dissimulant la complexité de l'API C derrière une simple interface script orientée objet. MapScript existe actuellement comme un module <ulink href="http://www.perl.com/">Perl 5</ulink>, mais il pourrait aussi être fait en <ulink url="http://www.tclconsortium.org">TK/TCL</ulink>, 
    <ulink url="http://www.python.org">Python</ulink> et <ulink url="http://java.sun.com/">Java</ulink>.
    </para>
		<para>L'organisation de MapScript est très proche de celle d'un <ulink url="mapfile-reference_fr.html">mapfile</ulink>. Il <emphasis>ne donne pas</emphasis> la fonctionnalité du programme CGI MapServer, au lieu de çà il fournit les éléments nécessaires pour construire vos propres versions personnalisées pour une utilisation sur le oueb ou comme des programmes autonomes. Voici un simple exemple perl qui charge un mapfile, crée une image et la sauvegarde.
    </para>
		<programlisting>
      #!/usr/bin/perl

      use mapscript;

      $map = new mapObj('example.map) or die('Unable to open mapfile.');
      $img = $map-&gt;draw() or die('Unable to draw map');
      mapscript::msSaveImage($img, 'example.gif', $map-&gt;{interlace}, $map-&gt;{transparent});
      </programlisting>
	</sect1>
	<!-- Changes -->
	<sect1 id="changes">
		<title>Changements depuis MapServer 3.3</title>
		<para>
      Summarize Changes Here
    </para>
	</sect1>
	<!-- USAGE -->
	<sect1 id="usage">
		<title>Utilisation</title>
		<para>
			<emphasis>Perl</emphasis> - use mapscript;
    </para>
	</sect1>
	<!-- CONSTANTS -->
	<sect1 id="usage">
		<title>Constantes</title>
		<para>
    Plusieurs paramètres <ulink url="mapfile-reference.html">map file</ulink> emploient des valeurs constantes. Les constantes suivantes sont autorisées dans MapScript.
    </para>
		<variablelist>
			<varlistentry>
				<term>valeurs booléennes</term>
				<listitem><para>MS_TRUE, MS_FALSE, MS_ON, MS_OFF, MS_YES, MS_NO</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>unités de carte</term>
				<listitem><para>MS_INCHES, MS_FEET, MS_MILES, MS_METERS, MS_KILOMETERS, MS_DD</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>types de couche</term>
				<listitem><para>MS_POINT, MS_LINE, MS_POLYGON, MS_POLYLINE, MS_RASTER, MS_ANNOTATION</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>types de police de caractères</term>
				<listitem><para>MS_TRUETYPE, MS_BITMAP</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>positions d'étiquette</term>
				<listitem><para>MS_UL, MS_LR, MS_UR, MS_LL, MS_CR, MS_CL, MS_UC, MS_LC, MS_CC, MS_AUTO</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>types de symbole</term>
				<listitem><para>MS_MARKERSET, MS_LINESET, MS_SHADESET</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>types de fichiers de forme</term>
				<listitem><para>MS_SHP_POINT, MS_SHP_ARC, MS_SHP_POLYGON, MS_SHP_MULTIPOINT</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>types de requête/jointure</term>
				<listitem><para>MS_SINGLE, MS_MULTIPLE</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
    Par exemple, dans la syntaxe perl la syntaxe est $mapscript::MS_ON ou $mapscript::MS_OFF.
    </para>
	</sect1>
	<!-- CLASSES/OBJECTS -->
	<sect1 id="class">
		<title>Classes/Objets</title>
		<itemizedlist>
			<title>L'accès à l'API MapServer se fait au moyen d'une série de classes. Ces classes permettent au programmeur de:</title>
			<listitem><para>manipuler virtuellement tous les aspects d'un <ulink url="mapfile-reference_fr.html">mapfile</ulink></para></listitem>
			<listitem><para>dessiner toutes cartes, couches ou des fichiers individuels de formes</para></listitem>
			<listitem><para>exécuter des requêtes géographiques en utilisant des points, des zones ou d'autres fonctions</para></listitem>
			<listitem><para>lire/écrire des fichiers de formes</para></listitem>
		</itemizedlist>
		<para>
    Les classes principales MapScript sont données dans le tableau suivant. Chaque classe est décrite en détail ultérieurement dans ce document.
    </para>
		<variablelist>
			<varlistentry>
				<term>mapObj</term>
				<listitem><para>gestion de tous les paramètres <ulink url="mapfile-reference_fr.html">mapfile</ulink></para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>layerObj</term>
				<listitem><para>gestion de tous les paramètres de couche, existe dans un mapObj</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>classObj</term>
				<listitem><para>gestion de tous les paramètres de classe, existe dans un layerObj</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>featureObj</term>
				<listitem><para>gestion des attributs d'une seule fonction intégrée, existe dans un layerObj</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>queryResultObj</term>
				<listitem><para>gestion des résultats d'une requête géographique (par point, zone ou fonction)</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>pointObj</term>
				<listitem><para>simple classe pour gérer un point 2-D</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>lineObj</term>
				<listitem><para>un lineObj est constitué de pointObjs, peut ou non faire parti d'un anneau fermé</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>shapeObj</term>
				<listitem><para>un shapeObj est constitué de lineObjs</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>rectObj</term>
				<listitem><para>classe utilisée pour représenter un rectangle 2-D, défini en utilisant les coordonnées x et y minimum et maximum</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>shapefileObj</term>
				<listitem><para>classe utilisée pour l'accès aux informations géographiques (les fonctions) enregistrées dans un fichier <ulink url="http://www.esri.com">ESRI</ulink> de formes</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>labelCacheMemberObj</term>
				<listitem><para>gestion d'un simple élément depuis le cache d'étiquette</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<!-- MapObj -->
		<sect2 id="mapObj">
			<title>mapObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
          new mapObj(filename), par exemple <programlisting>$map = new mapObj('foo.map');</programlisting>. Si le nom de fichier n'est pas défini un mapObj vide est créé et initialisé.
        </para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<para> Voyez la documentation <ulink url="mapfile-reference_fr.html">mapfile</ulink> pour une liste des paramètres qui peuvent être modifiés. Pour récupérer/donner les paramètres de couche vous aurez besoin d'utiliser les méthodes ci-après. Il est possible d'accéder individuellement à un élément pour les paramètres constitués d'une liste (size par exemple) - voir ci-après. Tous les noms de paramètres sont en <emphasis>minuscules</emphasis>. Seuls les membres qui ne sont pas décrits dans la documentation mapfile seront détaillés pour chaque objet MapScript. Il n'y a pas d'objets définissant les légendes, cartes référence et barres d'échelle puisque tous leurs paramètres sont accessibles via mapObj. Les ensembles de symboles et de polices de caractères ne sont pas encore disponibles via MapScript.
      </para>
				<itemizedlist>
					<listitem><para>
							<emphasis>size</emphasis> de carte, barre d'échelle et carte référence  utilise <varname>height</varname> (hauteur) et <varname>width</varname> (largeur) par exemple: $map-&gt;{scalebar}-&gt;{width} = 250;</para></listitem>
					<listitem><para> la zone de carte est un objet rectObj (voir plus loin)</para></listitem>
					<listitem><para>
							<emphasis>keysize</emphasis> de légende utilise <varname>keysizex</varname> et <varname>keysizey</varname></para></listitem>
					<listitem><para>
							<emphasis>keyspacing</emphasis> de légende utilise <varname>keyspacingx</varname> et <varname>keyspacingy</varname></para></listitem>
					<listitem><para> numlayers - nombre de couches dans la carte, lecture seule</para></listitem>
				</itemizedlist>
				<para>
      Voici quelques exemples illustrants l'accès aux membres:
      </para>
				<programlisting>
        $map-&gt;{extent}-&gt;{minx} = $minx;
        $map-&gt;{name} = 'test';
        $map-&gt;{scalebar}-&gt;{color} = $map-&gt;addColor($r, $g, $b);
        $map-&gt;{interlace} = $mapscript::MS_TRUE;
        $n = $map-&gt;{numlayers}; # numlayers is read-only
      </programlisting>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><replaceable>integer </replaceable><function>addColor(rouge, vert, bleu)</function> - Ajoute une couleur à la palette des cartes, retourne un index de couleur. Les valeurs de couleur se situent dans la plage 0 à 255. Doit être appelé avant d'exécuter draw() ou prepareImage().</member>
					<member><replaceable>image </replaceable><function>draw()</function> - restitue une carte, retourne une image.</member>
					<member><replaceable>image </replaceable><function>drawQueryMap()</function> - restitue une carte de requête, retourne une image.</member>
					<member><replaceable>integer </replaceable><function>drawLabelCache(image)</function> - restitue les étiquettes d'une carte. C'est aussi effectué en tant que partie de la méthode draw(), mais peut avoir besoin d'être appelé pour l'utilisation d'autres méthodes de restitution d'objet. Retourne -1 en cas d'erreur.</member>
					<member><replaceable>image </replaceable><function>drawLegend()</function> - restitue une légende, retourne une image.</member>
					<member><replaceable>image </replaceable><function>drawReferenceMap()</function> - restitue une carte référence, retourne une image.</member>
					<member><replaceable>image </replaceable><function>drawScalebar()</function> - restitue une barre d'échelle, retourne une image.</member>
					<member><replaceable>integer </replaceable><function>embedLegend()</function> - incruste une légende. Actuellement la légende est simplement ajoutée au cache d'étiquette aussi vous devez invoquer drawLabelCache()  pour effectuer la restitution (sauf si postlabelcache est utilisé).</member>
					<member><replaceable>integer </replaceable><function>embedScalebar()</function> - incruste une barre d'échelle. Actuellement la barre d'échelle est simplement ajoutée au cache d'étiquette aussi vous devez invoquer drawLabelCache()  pour effectuer la restitution (sauf si postlabelcache est utilisé).</member>
					<member><replaceable>layerObj </replaceable><function>getLayer(index)</function> - retourne un layerObj donnant une valeur d'index. 0 pour la première couche. Le nombre total de couches d'un mapfile est déterminé par $map-&gt;{numlayers}.</member>
					<member><replaceable>layerObj </replaceable><function>getLayerByName(name)</function> - retourne un layerObj donnant un nom de couche. 0 pour la première couche. Le nombre total de couches d'un mapfile est déterminé par $map-&gt;{numlayers}. Si des couches multiples existent avec le même nom la première occurence est retournée.</member>
					<member><replaceable>integer </replaceable><function>getSymbolByName(type, name)</function> - retourne l'index de symbole pour un symbole de type MS_MARKERSET, MS_LINESET ou MS_SHADESET et de nom name. Retourne -1 si le symbole n'est pas trouvé.</member>
					<member><replaceable>labelCacheMemberObj </replaceable><function>nextLabel()</function> - vous permet de marquer la progression du cache d'étiquette. Une raison pour celà serait de produire une image de carte basée sur l'annotation. Une autre serait de traiter une carte ultérieurement pour cacher le texte. Retourne une référence à un labelCacheMemberObj.</member>
					<member><replaceable>image </replaceable><function>prepareImage()</function> - initialise une image pour dessiner une carte, retourne une image. Doit être appelé avant d'appeler les méthodes de dessin pour les autres objets.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByPoint(point, type, buffer)</function> - interroge un  mapfile (un groupe de couches) en utilisant un point. Le type est MS_SINGLE ou MS_MULTIPLE selon le nombre de résultats souhaité. La tolérance par défaut est indiquée dans le mapfile mais peut utiliser à la place une valeur tampon constante. Retourne un queryResultObj.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByRect(rect)</function> - interroge un mapfile (un groupe de couches) en utilisant un rectangle. Retourne un queryResultObj.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByFeature(results)</function> - interroge un mapfile (un groupe de couches) en utilisant un autre ensemble de résultats. Retourne un queryResultObj.</member>
					<member><replaceable>integer </replaceable><function>save(filename)</function> - écrit les contextes du mapfile sur le disque. Retourne -1 en cas d'erreur.</member>
					<member><replaceable>integer </replaceable><function>setProjection(parameters)</function> - Détermine la projection et le système de coordonnées pour la carte. Retourne -1 en cas d'erreur. Les paramètres sont donnés sous forme d'une chaîne de caractères délimitée conforme à PROJ.4 . Par exemple, "proj=utm,ellps=GRS80,zone=15,north,no_defs".</member>
				</simplelist>
				<para>    
        Voici un exemple qui imprime la chaîne de caractères et l'entourage de polygone(s) pour toutes les étiquettes dans le cache qui doivent être dessinées:
	</para>
				<programlisting>
      while($label = $map-&gt;nextLabel()) {
        if($label-&gt;{status}) {
          print $label-&gt;{string} ."\n";

          $shape = $label-&gt;{poly};
          for($i=0; $i&lt;$shape-&gt;{numlines}; $i++) {
            $part = $shape-&gt;get($i);
            for($j=0; $j&lt;$part-&gt;{numpoints}; $j++) {
              $point = $part-&gt;get($j);
              print $point-&gt;{x} .",". $point-&gt;{y} ." ";
            }
            print "\n";
          }
        }
      }
        </programlisting>
			</simplesect>
		</sect2>
		<!-- layerObj -->
		<sect2>
			<title>layerObj</title>
			<simplesect>
				<title>Constructeur:</title>
				<para>
        new layerObj(map), par exemple <programlisting>$layer = new layerObj($map);</programlisting> Normalement vous obtenez un layerObj depuis une couche existante dans une carte, de toute façon, vous pouvez créer une nouvelle couche (dans une définition mapObj).
	</para>
			</simplesect>
			<simplesect>
				<title>Membres (voir la documentation <ulink url="mapfile-reference_fr.html">mapfile</ulink> pour une liste des paramètres qui peuvent être modifiés.)</title>
				<para> numclasses - nombre de classes dans la couche, lecture seule</para>
			</simplesect>
			<simplesect>
				<title>Méthodes:</title>
				<simplelist type="vert" columns="1">
					<member><replaceable>classObj </replaceable><function>getClass(index)</function> - retourne un classObj donné par une valeur d'index. 0 pour la première classe. Le nombre total de classes défini dans une classe est $class-&gt;{numclasses}.</member>
					<member><replaceable>integer </replaceable><function>draw(map, image)</function> - dessine une seule couche et ajoute des étiquettes au cache si nécessaire. Retourne 0 en cas de succès et -1 sinon.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByPoint(map, point, type, buffer)</function> - interroge une seule couche en utilisant un point. Le type est MS_SINGLE ou MS_MULTIPLE  selon le nombre de résultats souhaités. La tolérance par défaut est indiquée dans le mapfile mais peut utiliser une zone tampon constante. Retourne un queryResultObj.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByRect(map, rect)</function> - interroge une seule couche en utilisant un rectangle. Retourne un queryResultObj.</member>
					<member><replaceable>queryResultObj </replaceable><function>queryByFeature(map, results)</function> - interroge une seule couche en utilisant un autre ensemble de résultats. Retourne un queryResultObj.</member>
					<member><replaceable>integer </replaceable><function>setProjection(parameters)</function> - Indique la projection et le système de coordonnées pour la carte. Retourne -1 en cas d'erreur. Les paramètres sont donnés sous la forme d'une chaîne de caractères délimitée conforme à PROJ.4 . Par exemple, "proj=utm,ellps=GRS80,zone=15,north,no_defs".</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- queryResultObj -->
		<sect2>
			<title>queryResultObj</title>
			<simplesect>
				<title>Members</title>
				<simplelist type="vert" columns="1">
					<member> numresults - nombre total d'enregistrements correspondants</member>
					<member> numquerylayers - nombre total de couches correspondantes</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><replaceable>shapeResultObj </replaceable><function>next()</function> - retourne l'enregistrement résultat suivant. Chauqe enreigstrement (shapeResultObj) contient 4 valeurs d'index: layer (numéro de couche), tile (toujours -1 pour l'instant), shape (numéro d'enregistrement), et query (numéro de requête)</member>
					<member><function>free()</function> - libère la mémoire associée avec ces résultats. Puisqu'il n'y a pas de constructeur il n'y a pas non plus de destructeur vous devez appeler cette méthode ou laisser une fuite de mémoire.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- classObj -->
		<sect2>
			<title>classObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
        new classObj(layer), par exemple $class = new classObj($layer);  - fournit tous les accès pour tous les paramètres de classe (couleur, symbole, étiquette, etc...). 
	Normalement vous obtenez un classObj depuis une classe existante dans une couche, en tout état de cause, vous pouvez créer une nouvelle classe (dans une définition de couche).
	</para>
			</simplesect>
			<simplesect>
				<title>Membres (voir la documentation <ulink url="mapfile-reference_fr.html">mapfile</ulink> pour une liste des paramètres qui peuvent être modifiés.)</title>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<para>none</para>
			</simplesect>
		</sect2>
		<!-- pointObj -->
		<sect2>
			<title>pointObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
          new pointObj(), par exemple <programlisting>$point = new pointObj();</programlisting>
				</para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<simplelist type="vert" columns="1">
					<member> x - coordonnées x</member>
					<member> y - coordonnées y</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - dessine un point unique en utilisant la couche. La classe chaine est utilisée pour classifier le point basé sur les classes définies pour la couche. La chaîne texte est utilisée pour annoter le point. Retourne 0 en cas de succès et -1 sinon.
	  </member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- lineObj -->
		<sect2>
			<title>lineObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
          new lineObj(), par exemple <programlisting>$line = new lineObj();</programlisting>
				</para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<simplelist type="vert" columns="1">
					<member>numlines - numéro des lignes (parties) dans cette forme, lecture seule</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><function>add(point)</function> - ajoute un point à la fin d'une ligne.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- shapeObj -->
		<sect2>
			<title>shapeObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
         new shapeObj(type), par exemple <programlisting>$shape = new shapeObj($mapscript::MS_POLYGON);</programlisting>
				</para>
				<para>
        Le type de paramètre est juste un type général utilisé pour rendre MapScript moins volumineux. Avec ça MapScript peut évaluer plusieurs méthodes de comparaison (contient, inetrsecte) sans avoir un nombre important de méthodes spécifiques. Le type n'est pas utilisé d'une quelconque autre manière actuellement, aussi la plupart du temps une valeur de -1 devrait suffire. Les autres valeurs autorisées sont : MS_POINT, MS_LINE et MS_POLYGON. Les autres méthodes de création de forme (voir shapefileObj) renseignent ce paramètre correctement.
	</para>
			</simplesect>
			<simplesect>
				<title>Members</title>
				<simplelist type="vert" columns="1">
					<member> bounds - un rectObj contenant les périmètres de la forme, si disponible</member>
					<member> numlines - numéro des lignes (parties) dans cette forme, lecture seule</member>
					<member> type - type générique (MS_POINT, MS_LINE, MS_POLYGON) de cette forme</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Methods</title>
				<simplelist type="vert" columns="1">
					<member><function>add(line)</function> - ajoute une ligne à la forme.</member>
					<member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - dessine une forme individuelle en utilisant la couche. La classe de chaine est utilisée pour classifier le point basé sur les classes définies pour la couche. La chaine texte est utilisée pour annoter la forme. Retourne 0 en cas de succès et -1 sinon.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- featureObj -->
		<sect2>
			<title>featureObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
          new featureObj(layer), par exemple <programlisting>$feature = new featureObj($layer);</programlisting>
				</para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<simplelist type="vert" columns="1">
					<member>class - utilisé pour classifier la fonction si des classes multiples sont définies pour la couche</member>
					<member>text - utilisé pour annoter la fonction</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><function>add(line)</function> - ajoute une ligne à la fonction.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- rectObj -->
		<sect2>
			<title>rectObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
          new rectObj(), par exemple <programlisting>$rect = new rectObj();</programlisting>
				</para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<simplelist type="vert" columns="1">
					<member>minx, miny, maxx, maxy</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><replaceable>integer </replaceable><function>draw(map, layer, image, class, text)</function> - dessine un rectangle individuel en utilisant la couche. La classe chaine est utilisée pour classifier le point basé sur les classes pour la couche. La chaine texte est utilisée pour annoter le rectangle. Retourne 0 en cas de succès et -1 sinon.</member>
					<member><replaceable>double  </replaceable><function>fit(height, width)</function> - ajuste un rectangle (une zone) pour correspondre à la taille image. Le  cellsize (taille de cellule) en pixels est retourné.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- shapefileObj -->
		<sect2>
			<title>shapefileObj</title>
			<simplesect>
				<title>Constructeur</title>
				<para>
        new shapefileObj(filename, type), par exemple <programlisting>$shapefile = new shapeObj('lakes');</programlisting> Aucune extension n'est nécessaire. Pour les fichiers existant le type devrait être à -1, pour créer un fichier vide le type devrait être à l'une des valeurs: MS_SHP_POINT, MS_SHP_ARC, MS_SHP_POLYGON, ou MS_SHP_MULTIPOINT. Pour fermer un fichier de formes dans lequel vous avez écrit vous devez indéfinir la référence perl (par exemple undef $shapefile; ou $shapefile = '';).
	</para>
			</simplesect>
			<simplesect>
				<title>Membres</title>
				<simplelist type="vert" columns="1">
					<member>numshapes - numémro des formes dans le fichier de formes, lecture seule</member>
					<member>type - type du fichier de forme, lecture seule</member>
					<member>bounds - un rectObj contenant les fichiers de forme de rectangle</member>
				</simplelist>
			</simplesect>
			<simplesect>
				<title>Méthodes</title>
				<simplelist type="vert" columns="1">
					<member><function>get(index, shape)</function> - recherche une forme par son index.</member>
					<member><function>getExtent(index, rect)</function> - recherche un forme rectangle par son index.</member>
					<member><function>add(shape)</function> - ajoute une forme dans un fichier de forme ouvert.</member>
				</simplelist>
			</simplesect>
		</sect2>
		<!-- MISCELANEOUS FUNCTIONS -->
		<sect2>
 			<title>Fonctions diverses</title>
			<para>
        MapScript dispose de plusieurs fonctions diverses pour gérer l'image. Elles sont:
      </para>
			<simplelist>
				<member><function>msSaveImage(image, filename, transparent, interlace)</function> - sauvegarde une image dans un fichier. Indéfinissez le nom du fichier pour sauvegarder sur stdout. La transparence et l'entrelacement sont des valeurs booléennes.</member>
				<member><function>msFreeImage(image)</function> - libère la mémoire associée à une image.</member>
			</simplelist>
		</sect2>
	</sect1>
	<!-- ERROR HANDLING -->
	<sect1>
		<title>Gestion d'erreur</title>
	</sect1>
</article>
