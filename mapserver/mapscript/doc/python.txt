..  $Id$
    
    This is the new unified mapscript documentation prepared using
    reStructured Text.

    ***************************************************************
    RULE #1: No tabs in this document!
    RULE #2: Indent is 4 characters.
    RULE #3: There is no rule 3.

    Thank you.
    ***************************************************************
    
    reStructured Text is part of the Python docutils module
    
        http://docutils.sourceforge.net/
    
    Documentation on reStructured Text is found at

        http://docutils.sourceforge.net/rst.html

    First reST note is about comments: a double period begins a comment
    block (like a /* in C) and a double period on a line all by itself
    closes the comment block.
..

..  Below is our main heading (becomes H1).  Note that we require empty
    lines between every different reST element such as the empty line
    between the end of this comment and the begining of the heading.
..

*****************************************************************************
 Python Appendix
*****************************************************************************

:Author: Sean Gillies
:Contact: sgillies@frii.com
:Revision: $Revision$
:Date: $Date$

..  The next heading encountered becomes our H2
..

=============================================================================
 Introduction
=============================================================================

The Python mapscript module contains some class extension methods that have
not yet been implemented for other languages.

=============================================================================
 Classes
=============================================================================

References to sections below will be added here as the documentation grows.

-----------------------------------------------------------------------------
 imageObj
-----------------------------------------------------------------------------

The Python Imaging Library, http://www.pythonware.com/products/pil/, is an
indispensible tool for image manipulation.  The extensions to imageObj are
all geared towards better integration of PIL in mapscript applications.

Methods
-------

.. _new imageObj:

imageObj(int width, int height [, string driver [, PyObject file]]) : imageObj_
    Create a new instance which is either empty or read from a Python
    file-like object.  If *file* is provided, the size of the
    file's image override any other parameters passed to the method.  
    The *driver* must be specified as well as *file* as the method does
    not auto-detect the file's image format.
    
    If *file* is not specified an imageObj is created with the specified
    dimensions and of the format specified by *driver* or of a default
    format obtained by trying "GD/GIF", "GD/PNG", and "GD/JPEG" in that
    order.

    Interesting values of *file* to try are instances of *StringIO*

    ::

        s = StringIO()
        pil_image.save(s)    # Save an image manipulated with PIL
        ms_image = imageObj(0, 0, 'GD/PNG', s)

    Or the file-like object returned from *urlopen*

    ::
        
        url = urllib.urlopen('http://mapserver.gis.umn.edu/bugs/ant.jpg')
        ms_image = imageObj(0, 0, 'GD/JPEG', url)


    
.. _saveToString:

saveToString() : string
    Write the image data to a string rather than to a file.  What's the use
    of this?  Consider the following pointless example :)

    ::

        data = imgobj.saveToString()
        fh = open('foo.%s' % imgobj.format.extension, 'wb')
        fh.write(data)
        fh.close()

    Or the more useful example using PIL

    ::

        data = imgobj.saveToString()

        from StringIO import StringIO
        from PIL import Image

        pil_image = Image.open(StringIO(data))

        # Now do whatever you want using PIL

    This method will be deprecated as soon as we change the save() method
    of imageObj to save to Python file-like objects, allowing

    ::

        s = StringIO()
        imgobj.save(s)


------------------------------------------------------------------------------
 lineObj
------------------------------------------------------------------------------

Methods
-------

__iter__( ) : iterator
    Returns a Python iterator, allowing a new way to iterate over the points
    of a line:

    ::

        >>> line = shape.getLine(0)    # get first line of a shape
        >>> for p in line:
        ...     print (p.x, p.y)       # print point coordinates


    This is new Python syntax with potential to replace the traditional

    ::

        >>> line = shape.getLine(0)
        >>> for i in range(line.numpoints):
        ...     p = line.getPoint(i)
        ...     print (p.x, p.y)


------------------------------------------------------------------------------
 rectObj
------------------------------------------------------------------------------

Methods
-------

__contains__( pointObj point ) : boolean
    Returns True if *point* is inside the rectangle, otherwise returns False.

    ::

        >>> r = mapscript.rectObj(0, 0, 1, 1)
        >>> p = mapscript.pointObj(2, 0)       # outside
        >>> p in r
        False
        >>> p not in r
        True

    
__str__() : string
    Return a string formatted like

    ::

        { 'minx': %f , 'miny': %f , 'maxx': %f , 'maxy': %f }

    
    with the bounding values substituted appropriately.  Usage example:

    ::

        >>> r = mapscript.rectObj(0, 0, 1, 1)
        >>> str(r)
        { 'minx': 0.000000 , 'miny': 0.000000 , 'maxx': 1.000000 , 'maxy': 1.000000 }


    Note that the return value can be conveniently eval'd into a Python
    dictionary:

    ::

        >>> r_dict = eval(str(r))
        >>> r_dict['minx']
        0.000000


------------------------------------------------------------------------------
 shapeObj
------------------------------------------------------------------------------

Methods
-------

__contains__( pointObj point ) : boolean
    Returns True if *point* is inside the rectangle, otherwise returns False.

    ::

        >>> r = mapscript.rectObj(0, 0, 1, 1)
        >>> p = mapscript.pointObj(2, 0)       # outside
        >>> p in r
        False
        >>> p not in r
        True

